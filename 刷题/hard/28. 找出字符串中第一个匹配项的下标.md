## [28. 找出字符串中第一个匹配项的下标](https://leetcode.cn/problems/find-the-index-of-the-first-occurrence-in-a-string/)

给你两个字符串 `haystack` 和 `needle` ，请你在 `haystack` 字符串中找出 `needle` 字符串的第一个匹配项的下标（下标从 0 开始）。如果 `needle` 不是 `haystack` 的一部分，则返回 `-1` 。

 

**示例 1：**

```
输入：haystack = "sadbutsad", needle = "sad"
输出：0
解释："sad" 在下标 0 和 6 处匹配。
第一个匹配项的下标是 0 ，所以返回 0 。
```

**示例 2：**

```
输入：haystack = "leetcode", needle = "leeto"
输出：-1
解释："leeto" 没有在 "leetcode" 中出现，所以返回 -1 
```

```java
class Solution {
    public int strStr(String haystack, String needle) {
        // 获取两个字符串的长度
        int m = haystack.length(), n = needle.length();
        
        // 特殊情况，如果 needle 为空字符串，返回 0
        if (n == 0) return 0;

        // 构建 pi 数组（前缀函数）
        int[] pi = new int[n];
        
        // 计算 needle 字符串的 pi 数组（也叫 LPS 数组）
        for (int i = 1, j = 0; i < n; i++) {
            // 如果字符不匹配，利用 pi 数组的值跳过一些字符
            while (j > 0 && needle.charAt(i) != needle.charAt(j)) {
                j = pi[j - 1]; // 跳到前一个最长前缀后缀的位置
            }
            
            // 如果匹配，扩展 j 的值
            if (needle.charAt(i) == needle.charAt(j)) {
                j++;
            }
            
            // 更新 pi 数组的值，表示当前子串的最大前缀和后缀的长度
            pi[i] = j;
        }
        
        // 开始在 haystack 中查找 needle 字符串
        for (int i = 0, j = 0; i < m; i++) {
            // 如果字符不匹配，利用 pi 数组的值跳过一些字符
            while (j > 0 && haystack.charAt(i) != needle.charAt(j)) {
                j = pi[j - 1]; // 跳到前一个最长前缀后缀的位置
            }
            
            // 如果匹配，扩展 j 的值
            if (haystack.charAt(i) == needle.charAt(j)) {
                j++;
            }
            
            // 如果 j 达到 needle 的长度，表示找到了完整的匹配
            if (j == n) {
                return i - n + 1; // 返回匹配的起始位置
            }
        }
        
        // 如果没有找到匹配，返回 -1
        return -1;
    }
}

```

### 代码分析

- **前缀函数（`pi` 数组）**：用于记录当前字符串的前缀和后缀相同的最大长度。这个数组帮助我们避免重复的比较，提高效率。
- **第一部分（计算 `pi` 数组）**：
  - 我们用一个变量 `j` 来跟踪当前匹配的最长前缀后缀的长度。如果字符不匹配，`j` 会回溯到上一个匹配的位置（`pi[j-1]`）。这样可以避免重新检查已经匹配过的字符。
- **第二部分（在 `haystack` 中查找 `needle`）**：
  - 通过滑动窗口的方式，我们将 `haystack` 的每个字符与 `needle` 进行比较。当找到一个匹配时，我们将 `j` 加一，继续比较下一个字符。
  - 如果 `j` 达到 `needle` 的长度，表示我们已经找到一个匹配的子串，返回匹配的起始位置。
- **复杂度**：
  - 时间复杂度：O(m + n)，其中 `m` 是 `haystack` 的长度，`n` 是 `needle` 的长度。计算 `pi` 数组需要 O(n) 时间，在 `haystack` 中查找 `needle` 也需要 O(m) 时间。
  - 空间复杂度：O(n)，用于存储 `pi` 数组。

这段代码通过使用 **KMP 算法**（Knuth-Morris-Pratt）高效地解决了字符串匹配问题，比传统的暴力搜索更加高效。