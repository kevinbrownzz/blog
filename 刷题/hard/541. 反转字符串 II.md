## [541. 反转字符串 II](https://leetcode.cn/problems/reverse-string-ii/)

给定一个字符串 `s` 和一个整数 `k`，从字符串开头算起，每计数至 `2k` 个字符，就反转这 `2k` 字符中的前 `k` 个字符。

- 如果剩余字符少于 `k` 个，则将剩余字符全部反转。
- 如果剩余字符小于 `2k` 但大于或等于 `k` 个，则反转前 `k` 个字符，其余字符保持原样。

 

**示例 1：**

```
输入：s = "abcdefg", k = 2
输出："bacdfeg"
```

**示例 2：**

```
输入：s = "abcd", k = 2
输出："bacd"
```

### 解法一

```java
class Solution {
    // reverseStr 方法：对字符串进行翻转操作，每2k个字符进行处理
    public String reverseStr(String s, int k) {
        // StringBuffer 用于存储最终结果
        StringBuffer res = new StringBuffer();
        int length = s.length();  // 获取字符串的长度
        int start = 0;  // 初始化起始位置

        // 循环处理字符串，每次处理 2k 长度的部分
        while (start < length) {
            // 计算当前处理的前 k 个字符的结束位置
            int firstK = (start + k < length) ? start + k : length;
            // 计算当前处理的第二个 k 个字符的结束位置
            int secondK = (start + 2 * k < length) ? start + 2 * k : length;
            
            // 临时 StringBuffer 用于存储前 k 个字符并进行翻转
            StringBuffer temp = new StringBuffer();
            temp.append(s.substring(start, firstK));  // 获取字符串的前 k 个字符
            res.append(temp.reverse());  // 翻转并添加到结果中

            // 如果剩余部分存在，直接添加到结果中
            if (firstK < secondK) {
                res.append(s.substring(firstK, secondK));  // 添加第二部分的字符串
            }

            // 更新起始位置，跳过 2k 个字符
            start += (2 * k);
        }

        // 返回最终结果字符串
        return res.toString();
    }
}

```

### 关键部分标记：

1. **计算 `firstK` 和 `secondK`**：

   ```
   int firstK = (start + k < length) ? start + k : length;
   int secondK = (start + 2 * k < length) ? start + 2 * k : length;
   ```

   这两行代码确保了我们不会超出字符串的边界，分别计算每段的前 `k` 个字符和后续的第二段 `k` 个字符。

2. **翻转字符串的前 `k` 个字符**：

   ```
   StringBuffer temp = new StringBuffer();
   temp.append(s.substring(start, firstK));  // 获取前 k 个字符
   res.append(temp.reverse());  // 翻转并添加到结果中
   ```

   使用 `StringBuffer` 的 `reverse()` 方法来翻转从 `start` 到 `firstK` 的子字符串，并将其添加到结果 `res` 中。

3. **处理剩余的第二段字符**：

   ```
   if (firstK < secondK) {
       res.append(s.substring(firstK, secondK));  // 添加第二部分的字符串
   }
   ```

   如果第二段 `k` 个字符存在（即 `firstK < secondK`），就将其直接添加到结果中，不进行翻转。

4. **更新 `start` 的位置**：

   ```
   start += (2 * k);  // 更新起始位置，跳过 2k 个字符
   ```

   每次处理完一个 2k 长度的字符串后，将 `start` 更新为下一个部分的起始位置。

### 解法二

```java
class Solution {
    // reverseStr 方法：对字符串进行翻转操作，每2k个字符进行处理
    public String reverseStr(String s, int k) {
        // 将字符串转换为字符数组，以便直接修改字符
        char[] ch = s.toCharArray();

        // 每次处理 2k 长度的部分
        for (int i = 0; i < ch.length; i += 2 * k) {
            // 计算当前翻转部分的起始位置和结束位置
            int start = i;  // 起始位置为当前循环的起点
            int end = Math.min(ch.length - 1, i + k - 1);  // 结束位置为 i + k - 1 或者字符串的末尾

            // 对当前 [start, end] 范围内的字符进行翻转
            while (start < end) {
                // 使用 XOR 交换字符
                ch[start] ^= ch[end];  // 将 start 和 end 位置的字符异或
                ch[end] ^= ch[start];   // 通过异或交换字符
                ch[start] ^= ch[end];   // 完成交换
                start++;  // 移动起始位置
                end--;    // 移动结束位置
            }
        }

        // 将字符数组转换回字符串并返回结果
        return new String(ch);
    }
}

```

