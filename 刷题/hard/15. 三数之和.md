

## [15. 三数之和](https://leetcode.cn/problems/3sum/)

给你一个整数数组 `nums` ，判断是否存在三元组 `[nums[i], nums[j], nums[k]]` 满足 `i != j`、`i != k` 且 `j != k` ，同时还满足 `nums[i] + nums[j] + nums[k] == 0` 。请你返回所有和为 `0` 且不重复的三元组。

**注意：**答案中不可以包含重复的三元组。

**示例 1：**

```
输入：nums = [-1,0,1,2,-1,-4]
输出：[[-1,-1,2],[-1,0,1]]
解释：
nums[0] + nums[1] + nums[2] = (-1) + 0 + 1 = 0 。
nums[1] + nums[2] + nums[4] = 0 + 1 + (-1) = 0 。
nums[0] + nums[3] + nums[4] = (-1) + 2 + (-1) = 0 。
不同的三元组是 [-1,0,1] 和 [-1,-1,2] 。
注意，输出的顺序和三元组的顺序并不重要。
```

**示例 2：**

```
输入：nums = [0,1,1]
输出：[]
解释：唯一可能的三元组和不为 0 。
```

**示例 3：**

```
输入：nums = [0,0,0]
输出：[[0,0,0]]
解释：唯一可能的三元组和为 0 
```

#### 代码

```java
class Solution {
    public List<List<Integer>> threeSum(int[] nums) {
        List<List<Integer>> ans = new ArrayList<>();  // 存储所有符合条件的三元组
        Arrays.sort(nums);  // 排序数组，这样可以利用双指针法提高效率
        int size = nums.length;  
        
        // 如果数组长度小于3，则无法组成三元组，直接返回空列表
        if (nums == null || size < 3) return ans;
        
        // 外层循环：遍历数组中的每个元素作为三元组的第一个数
        for (int i = 0; i < size - 2; i++) {
            // 跳过重复元素，确保三元组不重复
            if (i > 0 && nums[i] == nums[i - 1]) continue;
            
            int target = -nums[i];  // 目标值是当前nums[i]的相反数，因为我们要找到两个数的和等于这个目标值
            int j = i + 1;  // 左指针，开始在i后面的位置
            int k = size - 1;  // 右指针，开始在数组的最后一个位置
            
            // 内层循环：双指针法查找两个数的和等于target
            while (j < k) {
                // 如果左指针和右指针的和等于目标值，则找到一个有效三元组
                if (nums[j] + nums[k] == target) {
                    // 将当前三元组加入到结果列表中
                    List<Integer> res = new ArrayList<>();
                    res.add(nums[i]);
                    res.add(nums[j]);
                    res.add(nums[k]);
                    ans.add(res);
                    
                    // 移动指针并跳过重复元素
                    j++;
                    k--;
                    
                    // 跳过重复的元素，避免出现重复的三元组
                    while (j < k && nums[j] == nums[j - 1]) j++;  // 跳过左边的重复元素
                    while (j < k && nums[k] == nums[k + 1]) k--;  // 跳过右边的重复元素
                } 
                // 如果两数和小于目标值，左指针右移
                else if (nums[j] + nums[k] < target) {
                    j++;
                } 
                // 如果两数和大于目标值，右指针左移
                else {
                    k--;
                }
            }
        }
        return ans;  // 返回所有找到的三元组
    }
}

```

### 关键步骤总结：

- **排序数组：** 让我们能够有效使用双指针法来查找三元组，并且跳过重复元素。
- **双指针法：** 通过调整指针来高效查找两数和等于目标值的组合，避免了暴力搜索的低效。
- **跳过重复元素：** 在外层和内层循环中都进行重复元素的跳过，避免了重复三元组的生成。