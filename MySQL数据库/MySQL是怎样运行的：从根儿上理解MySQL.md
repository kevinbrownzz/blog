# MySQL是怎样运行的：从根儿上理解MySQL

**1.6.1** **连接管理**

客户端进程可以采用我们上边介绍的 TCP/IP 、 命名管道或共享内存 、 Unix域套接字 这几种方式之一来与服务

器进程建立连接，每当有一个客户端进程连接到服务器进程时，服务器进程都会创建一个线程来专门处理与这个

客户端的交互，当该客户端退出时会与服务器断开连接，服务器并不会立即把与该客户端交互的线程销毁掉，而

是把它缓存起来，在另一个新的客户端再进行连接时，把这个缓存的线程分配给该新客户端。

**1.6.2** **解析与优化**

到现在为止， MySQL 服务器已经获得了文本形式的请求，接着 还要经过九九八十一难的处理，其中的几个比较

重要的部分分别是 查询缓存 、 语法解析 和 查询优化 ，下边我们详细来看。

**1.6.2.1** **查询缓存**

MySQL 服务器并没有人聪明，如果 <font color='red'>  两个查询请求在任何字符上的不同（例如：空格、注释、大小写），都会导致缓存不会命中。另外，如果查询请求中包含某些系统函数、用户自定义变量和函数、一些系统表，如mysql 、information_schema、 performance_schema 数据库中的表，那这个请求就不会被缓存 </font>。

不过既然是缓存，那就有它缓存失效的时候。MySQL的缓存系统会监测涉及到的每张表，只要该表的结构或者数据被修改，如对该表使用了<font color='red'> INSERT 、 UPDATE 、 DELETE 、 TRUNCATE TABLE 、 ALTER TABLE 、 DROP TABLE 或DROP DATABASE 语句，那使用该表的所有高速缓存查询都将变为无效并从高速缓存中删除！</font>

为了管理方便，人们把 连接管理 、 查询缓存 、 语法解析 、 查询优化 这些并不涉及真实数据存储的功能划分为 MySQL server 的功能，把真实存取数据的功能划分为 存储引擎 的功能。各种不同的存储引擎向上边的 MySQLserver 层提供统一的调用接口（也就是存储引擎API），包含了几十个底层函数，像"读取索引第一条内容"、"读取索引下一条内容"、"插入记录"等等。

**1.7** **常用存储引擎**

MySQL 支持非常多种存储引擎，我这先列举一些：

![image-20240717161255875](D:\desktop\笔记\MySQL数据库\img\mysql3.png)

**2.4.3** **设置系统变量**

**2.4.3.1** **通过启动选项设置**

大部分的 系统变量 都可以通过启动服务器时传送启动选项的方式来进行设置。如何填写启动选项我们上边已经

花了大篇幅来唠叨了，就是下边两种方式：

通过命令行添加启动选项。

比方说我们在启动服务器程序时用这个命令：

 ```sql
 mysqld --default-storage-engine=MyISAM --max-connections=10
 ```

通过配置文件添加启动选项。

我们可以这样填写配置文件：

 [server]

 default-storage-engine=MyISAM

 max-connections=10

```sql
mysql> SHOW VARIABLES LIKE 'default_storage_engine';
+------------------------+--------+
| Variable_name | Value |
+------------------------+--------+
| default_storage_engine | MyISAM |
+------------------------+--------+
1 row in set (0.00 sec)
```

系统变量 比较牛逼的一点就是，对于大部分系统变量来说，它们的值可以在服务器程序运行过程中进行动态修改而无需停止并重启服务器。不过系统变量有作用范围之分，下边详细唠叨下。

MySQL 的大叔提出了系统变量的 作用范围 的概念，具体来说 作用范围 分为这两种：

GLOBAL ：全局变量，影响服务器的整体操作。

SESSION ：会话变量，影响某个客户端连接的操作。（注： SESSION 有个别名叫 LOCAL ）

**2.5** **状态变量**

 

状态变量 是用来显示服务器程序运行状况的，所以它们的值只能由服务器程序自己来设置，我们程序员是不能设置的。与 系统变量 类似， 状态变量 也有 GLOBAL 和 SESSION 两个作用范围的，所以查看 状态变量 的语句可以这么写：

SHOW [GLOBAL|SESSION] STATUS [LIKE 匹配的模式];

**3.3.1** **各级别的字符集和比较规则**

MySQL 有4个级别的字符集和比较规则，分别是：

* 服务器级别

* 数据库级别

* 表级别

* 列级别

**3.3.1.1** **服务器级别**

MySQL 提供了两个系统变量来表示服务器级别的字符集和比较规则：

**系统变量** 

**描述**

character_set_server 

服务器级别的字符集

collation_server 

服务器级别的比较规则

我们看一下这两个系统变量的值：

```sql
mysql> SHOW VARIABLES LIKE 'character_set_server';

+----------------------+-------+

| Variable_name | Value |

+----------------------+-------+

| character_set_server | utf8 |

+----------------------+-------+

1 row in set (0.00 sec)

mysql> SHOW VARIABLES LIKE 'collation_server';

+------------------+-----------------+

| Variable_name | Value |

+------------------+-----------------+

| collation_server | utf8_general_ci |

+------------------+-----------------+
```

**3.4** **总结**

* \1. 字符集 指的是某个字符范围的编码规则。

* \2. 比较规则 是针对某个字符集中的字符比较大小的一种规则。

* \3. 在 MySQL 中，一个字符集可以有若干种比较规则，其中有一个默认的比较规则，一个比较规则必须对应一个

字符集。

* \4. 查看 MySQL 中查看支持的字符集和比较规则的语句如下：

SHOW (CHARACTER SET|CHARSET) [LIKE 匹配的模式];

SHOW COLLATION [LIKE 匹配的模式];

## 4第4章 从一条记录说起-InnoDB记录结

**4.2 InnoDB页简介**

InnoDB 采取的方式是：将数据划分为若干个页，以页作为磁盘和内存之间交互的基本单位，InnoDB中页的大小一般为 **16** KB。也就是在一般情况下，一次最少从磁盘中读取16KB的内容到内存中，一次最少把内存中的16KB内容刷新到磁盘中

**4.3 InnoDB****行格式**

我们平时是以记录为单位来向表中插入数据的，这些记录在磁盘上的存放方式也被称为 行格式 或者 记录格式 。设计 InnoDB 存储引擎的大叔们到现在为止设计了4种不同类型的 行格式 ，分别是 Compact 、 Redundant 、Dynamic 和 Compressed 行格式，随着时间的推移，他们可能会设计出更多的行格式，但是不管怎么变，在原理上大体都是相同的。

### **4.3.2 COMPACT****行格式**

废话不多说，直接看图：

![image-20240719100753043](D:\desktop\笔记\MySQL数据库\img\mysql4.png)

**4.3.2.1** **记录的额外信息**

这部分信息是服务器为了描述这条记录而不得不额外添加的一些信息，这些额外信息分为3类，分别是 变长字段长度列表 、 NULL值列表 和 记录头信息 ，我们分别看一下。

所以这些变长字段占用的存储空间分为两部分：

* \1. 真正的数据内容

* \2. 占用的字节数

在 Compact 行格式中，<font color = 'red'> 把所有变长字段的真实数据占用的字节长度都存放在记录的开头部位，从而形成一个变长字段长度列表，各变长字段数据占用的字节数按照列的顺序逆序存放，我们再次强调一遍，是逆序存放！</font>

由于第一行记录中 c1 、 c2 、 c4 列中的字符串都比较短，也就是说内容占用的字节数比较小，用1个字节就可以表示，但是如果变长列的内容占用的字节数比较多，可能就需要用2个字节来表示。具体用1个还是2个字节来表示真实数据占用的字节数， InnoDB 有它的一套规则，我们首先声明一下 W 、 M 和 L 的意思：

* \1. 假设某个字符集中表示一个字符最多需要使用的字节数为 W ，也就是使用 SHOW CHARSET 语句的结果中的Maxlen 列，比方说 utf8 字符集中的 W 就是 3 ， gbk 字符集中的 W 就是 2 ， ascii 字符集中的 W 就是1 。

* \2. 对于变长类型 VARCHAR(M) 来说，这种类型表示能存储最多 M 个字符（注意是字符不是字节），所以这个类型能表示的字符串最多占用的字节数就是 M×W 。

* \3. 假设它实际存储的字符串占用的字节数是 L 。

所以确定使用1个字节还是2个字节表示真正字符串占用的字节数的规则就是这样：

如果 M×W <= 255 ，那么使用1个字节来表示真正字符串占用的字节数。

 也就是说InnoDB在读记录的变长字段长度列表时先查看表结构，如果某个变长字段允许存储的最

大字节数不大于255时，可以认为只使用1个字节来表示真正字符串占用的字节数。

如果 M×W > 255 ，则分为两种情况：

如果 L <= 127 ，则用1个字节来表示真正字符串占用的字节数。

如果 L > 127 ，则用2个字节来表示真正字符串占用的字节数

#### **NULL**值列表

二进制位的值为 1 时，代表该列的值为 NULL 。

二进制位的值为 0 时，代表该列的值不为 NULL 。

再一次强调，二进制位按照列的顺序逆序排列，所以第一个列 c1 和最后一个二进制位对应。

MySQL 规定 NULL值列表 必须用整数个字节的位表示，如果使用的二进制位个数不是整数个字节，则在字节

的高位补 0 。

#### 记录头信息

![image-20240719102747182](D:\desktop\笔记\MySQL数据库\img\mysql5.png)

**4.3.2.2** **记录的真实数据**

对于 record_format_demo 表来说， 记录的真实数据 除了 c1 、 c2 、 c3 、 c4 这几个我们自己定义的列的数据以外， MySQL 会为每个记录默认的添加一些列（也称为 隐藏列 ），具体的列如下：

这里需要提一下 InnoDB 表对主键的生成策略：优先使用用户自定义主键作为主键，如果用户没有定义主键，则

选取一个 Unique 键作为主键，如果表中连 Unique 键都没有定义的话，则 InnoDB 会为表默认添加一个名为

row_id 的隐藏列作为主键。所以我们从上表中可以看出：InnoDB存储引擎会为每条记录都添加 **transaction_id**和 **roll_pointer** 这两个列，但是 **row_id** 是可选的（在没有自定义主键以及Unique键的情况下才会添加该列）。

这些隐藏列的值不用我们操心， InnoDB 存储引擎会自己帮我们生成的。

![image-20240719103031541](D:\desktop\笔记\MySQL数据库\img\mysql6.png)

![image-20240719103108318](D:\desktop\笔记\MySQL数据库\img\sql7.png)

* \1. 表 record_format_demo 使用的是 ascii 字符集，所以 0x61616161 就表示字符串 'aaaa' ， 0x626262 就表示字符串 'bbb' ，以此类推。

* \2. 注意第1条记录中 c3 列的值，它是 CHAR(10) 类型的，它实际存储的字符串是： 'cc' ，而 ascii 字符集中的字节表示是 '0x6363' ，虽然表示这个字符串只占用了2个字节，但整个 c3 列仍然占用了10个字节的空间，<font color = 'red'>除真实数据以外的8个字节的统统都用空格字符填充，空格字符在 ascii 字符集的表示就是 0x20 。</font>

* \3. 注意第2条记录中 c3 和 c4 列的值都为 NULL ，它们被存储在了前边的 NULL值列表 处，在记录的真实数据处就不再冗余存储，从而节省存储空间

变长字符集的 CHAR(M) 类型的列要求至少占用 M 个字节，而 VARCHAR(M) 却没有这个要求。比方说对于使用 utf8 字符集的 CHAR(10) 的列来说，该列存储的数据字节长度的范围是10～30个字节。即使我们向该列中存储一个空字符串也会占用 10 个字节，这是怕将来更新该列的值的字节长度大于原有值的字节长度而小于10个字节时，可以在该记录处直接更新，而不是在存储空间中重新分配一个新的记录空间，导致原有的记录空间成为所谓的碎片。（这里你感受到设计 Compact 行格式的大叔既想节省存储空间，又不想更新CHAR(M) 类型的列产生碎片时的纠结心情了吧。）

### **4.3.3 Redundant****行格式**

![image-20240719104302552](D:\desktop\笔记\MySQL数据库\img\mysql8.png)

从图中可以看出来，对于 Compact 和 Reduntant 行格式来说，如果某一列中的数据非常多的话，在本记录的真实数据处只会存储该列的前 768 个字节的数据和一个指向其他页的地址，然后把剩下的数据存放到其他页中，这个过程也叫做 行溢出 ，存储超出 768 字节的那些页面也被称为 溢出页 。画一个简图就是这样：

![image-20240719111152322](D:\desktop\个人\摄影\3.png)

### **4.3.5 Dynamic****和****Compressed****行格式**

下边要介绍另外两个行格式， Dynamic 和 Compressed 行格式，我现在使用的 MySQL 版本是 5.7 ，它的默认行格式就是 Dynamic ，这俩行格式和 Compact 行格式挺像，只不过在处理 行溢出 数据时有点儿分歧，它们在记录的真实数据处存储字段真实数据的前 768 个字节，而是把所有的字节都存储到其他页面中，只在记录的真实数据处存储其他页面的地址，就像这样：

![image-20240719111342520](D:\desktop\笔记\MySQL数据库\img\sql8.png)

### **4.4** **总结**

* \1. 页是 MySQL 中磁盘和内存交互的基本单位，也是 MySQL 是管理存储空间的基本单位。

* \2. 指定和修改行格式的语法如下：

​			CREATE TABLE 表名 (列的信息) ROW_FORMAT=行格式名称

​			ALTER TABLE 表名 ROW_FORMAT=行格式名称

* \3. InnoDB 目前定义了4种行格式

​			COMPACT行格式

​			具体组成如图：Redundant行格式

​			具体组成如图：

​				Dynamic和Compressed行格式

​			这两种行格式类似于 COMPACT行格式 ，只不过在处理行溢出数据时有点儿分歧，它们不会在记录的			真实数据处存储字符串的前768个字节，而是把所有的字节都存储到其他页面中，只在记录的真实数据			处存储其他页面的地址。

​			另外， Compressed 行格式会采用压缩算法对页面进行压缩。

* \4. 一个页一般是 16KB ，当记录中的数据太多，当前页放不下的时候，会把多余的数据存储到其他页中，这种现象称为 行溢出



## **5** **第**5章 盛放记录的大盒子-InnoDB**数据页结构**

数据页代表的这块 16KB 大小的存储空间可以被划分为多个部分，不同部分有不同的功能

![image-20240719113318557](D:\desktop\笔记\MySQL数据库\img\sql9.png)

![image-20240719114158291](D:\desktop\笔记\MySQL数据库\img\sql10.png)

* \1.将所有正常的记录（包括最大和最小记录，不包括标记为已删除的记录）划分为几个组。

* \2. 每个组的最后一条记录（也就是组内最大的那条记录）的头信息中的 n_owned 属性表示该记录拥有多少条记录，也就是该组内共有几条记录。

* \3. 将每个组的最后一条记录的地址偏移量单独提取出来按顺序存储到靠近 页 的尾部的地方，这个地方就是所谓的 Page Directory ，也就是 页目录 （此时应该返回头看看页面各个部分的图）。页面目录中的这些地址偏移量被称为 槽 （英文名： Slot ），所以这个页面目录就是由槽组成的。



设计 InnoDB 的大叔们对每个分组中的记录条数是有规定的：对于最小记录所在的分组只能有 **1** 条记录，

最大记录所在的分组拥有的记录条数只能在 **1~8** 条之间，剩下的分组中记录的条数范围只能在是 **4~8** 条之间。

所以分组是按照下边的步骤进行的：

初始情况下一个数据页里只有最小记录和最大记录两条记录，它们分属于两个分组。之后每插入一条记录，都会从 页目录 中找到主键值比本记录的主键值大并且差值最小的槽，然后把该槽对应的记录的 n_owned 值加1，表示本组内又添加了一条记录，直到该组中的记录数等于8个。在一个组中的记录数等于8个后再插入一条记录时，会将组中的记录拆分成两个组，一个组中4条记录，另一个5条记录。这个过程会在 页目录 中新增一个 槽 来记录这个新增分组中最大的那条记录的偏移量。

![image-20240719143453370](D:\desktop\笔记\MySQL数据库\img\sql11.png)

所以在一个数据页中查找指定主键值的记录的过程分为两步：

<font color = 'red'>\1. 通过二分法确定该记录所在的槽，并找到该槽中主键值最小的那条记录。\2. 通过记录的 next_record 属性遍历该槽所在的组中的各个记录。</font>

##### **5.5 Page Header****（页面头部）**

设计 InnoDB 的大叔们为了能得到一个数据页中存储的记录的状态信息，比如本页中已经存储了多少条记录，第一条记录的地址是什么，页目录中存储了多少个槽等等，特意在页中定义了一个叫 Page Header 的部分，它是页 结构的第二部分，这个部分占用固定的 56 个字节，专门存储各种状态信息，具体各个字节都是干嘛的看下

![image-20240719143842177](D:\desktop\笔记\MySQL数据库\img\sql12.png)

##### **5.6 File Header****（文件头部）**

Page Header 是专门针对 数据页 记录的各种状态信息，比方说页里头有多少个记录了呀，有多少个槽了呀。我们现在描述的 File Header 针对各种类型的页都通用，也就是说不同类型的页都会以 File Header 作为第一个组成部分，它描述了一些针对各种页都通用的一些信息，比方说这个页的编号是多少，它的上一个页、下一个页是谁

这个部分占用固定的 38 个字节

![image-20240719144542627](D:\desktop\笔记\MySQL数据库\img\sql13.png)

 

| 类型名称 | 十六进制 | 描述 |
| -------- | -------- | ---- |
|          |          |      |

| FIL_PAGE_TYPE_ALLOCATED | 0x0000 | 最新分配，还没使用 |
| ----------------------- | ------ | ------------------ |
|                         |        |                    |

| FIL_PAGE_UNDO_LOG | 0x0002 | Undo日志页 |
| :---------------- | ------ | ---------- |
|                   |        |            |

| FIL_PAGE_INODE | 0x0003 | 段信息节点 |
| -------------- | ------ | ---------- |
|                |        |            |

| FIL_PAGE_IBUF_FREE_LIST | 0x0004 | Insert Buffer空闲列表 |
| ----------------------- | ------ | --------------------- |
|                         |        |                       |



| FIL_PAGE_IBUF_BITMAP | 0x0005 | Insert Buffer位图 |
| -------------------- | ------ | ----------------- |
|                      |        |                   |

| FIL_PAGE_TYPE_SYS | 0x0006 | 系统页 |
| ----------------- | ------ | ------ |
|                   |        |        |



| FIL_PAGE_TYPE_TRX_SYS | 0x0007 | 事务系统数据 |
| --------------------- | ------ | ------------ |
|                       |        |              |

| FIL_PAGE_TYPE_FSP_HDR | 0x0008 | 表空间头部信息 |
| --------------------- | ------ | -------------- |
|                       |        |                |



| FIL_PAGE_TYPE_XDES | 0x0009 | 扩展描述页 |
| ------------------ | ------ | ---------- |
|                    |        |            |

| FIL_PAGE_TYPE_BLOB | 0x000A | BLOB页 |
| ------------------ | ------ | ------ |
|                    |        |        |

| FIL_PAGE_INDEX | 0x45BF | 索引页，也就是我们所说的 数据页 |
| -------------- | ------ | ------------------------------- |
|                |        |                                 |

![image-20240719145130450](D:\desktop\笔记\MySQL数据库\img\sql14.png)

##### **5.8** **总结**

* \1. InnoDB为了不同的目的而设计了不同类型的页，我们把用于存放记录的页叫做 数据页 。

* \2. 一个数据页可以被大致划分为7个部分，分别是

​			File Header ，表示页的一些通用信息，占固定的38字节。

​			Page Header ，表示数据页专有的一些信息，占固定的56个字节。

​			Infimum + Supremum ，两个虚拟的伪记录，分别表示页中的最小和最大记录，占固定的 26 个字节。

​			User Records ：真实存储我们插入的记录的部分，大小不固定。

​			Free Space ：页中尚未使用的部分，大小不确定。Page Directory ：页中的某些记录相对位置，也就是各个槽在页面中的地址偏移量，大小不固定，插入的记录越多，这个部分占用的空间越多。

​			File Trailer ：用于检验页是否完整的部分，占用固定的8个字节。

* \3. 每个记录的头信息中都有一个 next_record 属性，从而使页中的所有记录串联成一个 单链表 。

* \4. InnoDB 会为把页中的记录划分为若干个组，每个组的最后一个记录的地址偏移量作为一个 槽 ，存放在Page Directory 中，所以在一个页中根据主键查找记录是非常快的，分为两步：通过二分法确定该记录所在的槽。通过记录的next_record属性遍历该槽所在的组中的各个记录。

* \5. 每个数据页的 File Header 部分都有上一个和下一个页的编号，所以所有的数据页会组成一个 双链表 。

* \6. 为保证从内存中同步到磁盘的页的完整性，在页的首部和尾部都会存储页中数据的校验和和页面最后修改时

对应的 LSN 值，如果首部和尾部的校验和和 LSN 值校验不成功的话，就说明同步过程出现了问题。

## **6** 第6章 快速查询的秘籍-B+树索引

前边我们详细唠叨了 InnoDB 数据页的7个组成部分，知道了

<font color = 'red'>各个数据页可以组成一个 双向链表 ，而每个数据页中的记录会按照主键值从小到大的顺序组成一个 单向链表 ，每个数据页都会为存储在它里边儿的记录生成一个页目录 ，在通过主键查找某条记录的时候可以在 页目录 中使用二分法快速定位到对应的槽，然后再遍历该槽对应分组中的记录即可快速找到指定的记录. </font>

![image-20240719145816684](D:\desktop\笔记\MySQL数据库\img\sql15.png)

**6.1** **没有索引的查找**

###### **6.1.1** **在一个页中的查找**

假设目前表中的记录比较少，所有的记录都可以被存放到一个页中，在查找记录的时候可以根据搜索条件的不同

分为两种情况：

* 以主键为搜索条件这个查找过程我们已经很熟悉了，可以在 页目录 中使用二分法快速定位到对应的槽，然后再遍历该槽对应分组中的记录即可快速找到指定的记录。

* 以其他列作为搜索条件

##### **6.1.2** **在很多页中查找**

大部分情况下我们表中存放的记录都是非常多的，需要好多的数据页来存储这些记录。在很多页中查找记录的话

可以分为两个步骤：

* \1. 定位到记录所在的页。

* \2. 从所在的页内中查找相应的记录。





#### **6.2** **索引**

![image-20240719165853064](D:\desktop\笔记\MySQL数据库\img\sql16.png)

* record_type ：记录头信息的一项属性，表示记录的类型， 0 表示普通记录、 2 表示最小记录、 3 表示最大记录、 1 我们还没用过，等会再说～

* next_record ：记录头信息的一项属性，表示下一条地址相对于本条记录的地址偏移量，为了方便大家理解，我们都会用箭头来表明下一条记录是谁。

* 各个列的值 ：这里只记录在 index_demo 表中的三个列，分别是 c1 、 c2 和 c3 。

* 其他信息 ：除了上述3种信息以外的所有信息，包括其他隐藏列的值以及记录的额外信息。

##### **6.2.2 InnoDB****中的索引方案**

上边之所以称为一个简易的索引方案，是因为我们为了在根据主键值进行查找时使用二分法快速定位具体的目录项而假设所有目录项都可以在物理存储器上连续存储，但是这样做有几个问题：

InnoDB 是使用页来作为管理存储空间的基本单位，也就是最多能保证 16KB 的连续存储空间，而随着表中记录数量的增多，需要非常大的连续的存储空间才能把所有的目录项都放下，这对记录数量非常多的表是不现实的。

设计 InnoDB 的大叔们需要一种可以灵活管理所有 目录项 的方式。他们灵光乍现，忽然发现这些 目录项其实长得跟我们的用户记录差不多，只不过 目录项 中的两个列是 主键 和 页号 而已，所以他们复用了之前存储用户记录的数据页来存储目录项，为了和用户记录做一下区分，我们把这些用来表示目录项的记录称为 目录项记录 。那 InnoDB 怎么区分一条记录是普通的 用户记录 还是 目录项记录 呢？别忘了记录头信息里的record_type 属性，它的各个取值代表的意思如下：

* 0 ：普通的用户记录

* 1 ：目录项记录

* 2 ：最小记录

* 3 ：最大记录

次强调一遍 目录项记录和普通的 用户记录 的不同点：目录项记录 的 record_type 值是1，而普通用户记录的 record_type 值是0。

目录项记录 只有主键值和页的编号两个列，而普通的用户记录的列是用户自己定义的，可能包含很多列，另外还有 InnoDB 自己添加的隐藏列。还记得我们之前在唠叨记录头信息的时候说过一个叫 min_rec_mask 的属性么，只有在存储 目录项记录 的页中的主键值最小的 目录项记录 的 min_rec_mask 值为 1 ，其他别的记录的 min_rec_mask 值都是 0 。

<font color = 'red'>目录项记录 中只存储主键值和对应的页号。</font>

我们想根据主键值查找一条用户记录大致需要3个步骤，以查找主键值为 20 的记录为例：

* \1. 确定 目录项记录 页
* * 我们现在的存储 目录项记录 的页有两个，即 页30 和 页32 ，又因为 页30 表示的目录项的主键值的范围是[1, 320) ， 页32 表示的目录项的主键值不小于 320 ，所以主键值为 20 的记录对应的目录项记录在 页30中。

* \2. 通过 目录项记录 页确定用户记录真实所在的页。

* \3. 在真实存储用户记录的页中定位到具体的记录。

![image-20240722115721052](D:\desktop\笔记\MySQL数据库\img\sql17.png)

<font color = 'red'>我们的实际用户记录其实都存放在B+树的最底层的节点上，这些节点也被称为 叶子节点 或 叶节点 ，其余用来存放 目录项 的节点称为 非叶子节点 或者 内节点 ，其中 B+ 树最上边的那个节点也称为 根节点 。</font>

一般情况下，我们用到的 B+ 树都不会超过4层，那我们通过主键值去查找某条记录最多只需要做4个页面内的查找（查找3个目录项页和一个用户记录页），又因为在每个页面内有所谓的 Page Directory （页目录），所以在页面内也可以通过二分法实现快速定位记录，

##### **6.2.2.1** **聚簇索引**

我们上边介绍的 B+ 树本身就是一个目录，或者说本身就是一个索引。它有两个特点：

* \1. 使用记录主键值的大小进行记录和页的排序，这包括三个方面的含义：页内的记录是按照主键的大小顺序排成一个单向链表。各个存放用户记录的页也是根据页中用户记录的主键大小顺序排成一个双向链表。存放目录项记录的页分为不同的层次，在同一层次中的页也是根据页中目录项记录的主键大小顺序排成一个双向链表。

* \2. B+ 树的叶子节点存储的是完整的用户记录。

所谓完整的用户记录，就是指这个记录中存储了所有列的值（包括隐藏列）。

我们把具有这两种特性的 B+ 树称为 聚簇索引 ，所有完整的用户记录都存放在这个 聚簇索引 的叶子节点处。这种 聚簇索引 并不需要我们在 MySQL 语句中显式的使用 INDEX 语句去创建（后边会介绍索引相关的语句），InnoDB 存储引擎会自动的为我们创建聚簇索引。另外有趣的一点是，在 InnoDB 存储引擎中， 聚簇索引 就是数据的存储方式（所有的用户记录都存储在了 叶子节点 ），也就是所谓的索引即数据，数据即索引。

##### **6.2.2.2** **二级索引**

大家有木有发现，上边介绍的 聚簇索引 只能在搜索条件是主键值时才能发挥作用，因为 B+ 树中的数据都是按照主键进行排序的。那如果我们想以别的列作为搜索条件该咋办呢？难道只能从头到尾沿着链表依次遍历记录么？不，我们可以多建几棵 B+ 树，不同的 B+ 树中的数据采用不同的排序规则。比方说我们用 c2 列的大小作为数据页、页中记录的排序规则，再建一棵 B+ 树，效果如下图所示：

![image-20240722115923463](D:\desktop\笔记\MySQL数据库\img\sql18.png)

这个 B+ 树与上边介绍的聚簇索引有几处不同：

使用记录 c2 列的大小进行记录和页的排序，这包括三个方面的含义：页内的记录是按照 c2 列的大小顺序排成一个单向链表。

* 各个存放用户记录的页也是根据页中记录的 c2 列大小顺序排成一个双向链表。

* 存放目录项记录的页分为不同的层次，在同一层次中的页也是根据页中目录项记录的 c2 列大小顺序排

* 成一个双向链表。

B+ 树的叶子节点存储的并不是完整的用户记录，而只是 c2列+主键 这两个列的值。

目录项记录中不再是 主键+页号 的搭配，而变成了 c2列+页号 的搭配。

<font color = 'red'>我们必须再根据主键值去聚簇索引中再查找一遍完整的用户记录。</font>

我们想根据 c2 列的值查找到完整的用户记录的话，仍然需要到 聚簇索引 中再查一遍，这个过程也被称为 回表 。也就是根据 c2 列的值查询一条完整的用户记录需要使用到 2 棵 B+ 树！！！

为什么我们还需要一次 回表 操作呢？直接把完整的用户记录放到 叶子节点 不就好了么？你说的对，如果把完整

的用户记录放到 叶子节点 是可以不用 回表 ，但是太占地方了呀～相当于每建立一棵 B+ 树都需要把所有的用户记录再都拷贝一遍，这就有点太浪费存储空间了。因为这种按照 非主键列 建立的 B+ 树需要一次 回表 操作才可以定位到完整的用户记录，所以这种 B+ 树也被称为 二级索引 （英文名 secondary index ），或者 辅助索引 。

由于我们使用的是 c2 列的大小作为 B+ 树的排序规则，所以我们也称这个 B+ 树为为c2列建立的索引。

##### 联合索引

我们也可以同时以多个列的大小作为排序规则，也就是同时为多个列建立索引，比方说我们想让 B+ 树按照 c2

和 c3 列的大小进行排序，这个包含两层含义：

* 先把各个记录和页按照 c2 列进行排序。

* 在记录的 c2 列相同的情况下，采用 c3 列进行排序

![image-20240722120719902](D:\desktop\笔记\MySQL数据库\img\sql19.png)

如图所示，我们需要注意一下几点：

* 每条 目录项记录 都由 c2 、 c3 、 页号 这三个部分组成，各条记录先按照 c2 列的值进行排序，如果记录的 c2 列相同，则按照 c3 列的值进行排序。

* B+ 树叶子节点处的用户记录由 c2 、 c3 和主键 c1 列组成。

千万要注意一点，以c2和c3列的大小为排序规则建立的B+树称为联合索引，本质上也是一个二级索引。它的意思与分别为c2和c3列分别建立索引的表述是不同的，不同点如下：

* 建立 联合索引 只会建立如上图一样的1棵 B+ 树。

* 为c2和c3列分别建立索引会分别以 c2 和 c3 列的大小为排序规则建立2棵 B+ 树。

###### 6.2.4 MyISAM中的索引方案简单介绍

知道 InnoDB 中索引即数据，也就是聚簇索引的那棵 B+ 树的叶子节点中已经把所有完整的用户记录都包含了，而 MyISAM 的索引方案虽然也使用树形结构，但是却将索引和数据分开存储：

将表中的记录按照记录的插入顺序单独存储在一个文件中，称之为 数据文件 。这个文件并不划分为若干个数据页，有多少记录就往这个文件中塞多少记录就成了。我们可以通过行号而快速访问到一条记录。

![image-20240722143634823](D:\desktop\笔记\MySQL数据库\img\sql20.png)

由于在插入数据的时候并没有刻意按照主键大小排序，所以我们并不能在这些数据上使用二分法进行查找。使用 MyISAM 存储引擎的表会把索引信息另外存储到一个称为 索引文件 的另一个文件中。 MyISAM 会单独为表的主键创建一个索引，只不过在索引的叶子节点中存储的不是完整的用户记录，而是 主键值 + 行号 的组合。也就是先通过索引找到对应的行号，再通过行号去找对应的记录！

这一点和 InnoDB 是完全不相同的，在 InnoDB 存储引擎中，我们只需要根据主键值对 聚簇索引 进行一次查找就能找到对应的记录，而在 MyISAM 中却需要进行一次 回表 操作，意味着 MyISAM 中建立的索引相当于全部都是 二级索引 ！

如果有需要的话，我们也可以对其它的列分别建立索引或者建立联合索引，原理和 InnoDB 中的索引差不多，不过在叶子节点处存储的是 相应的列 + 行号 。这些索引也全部都是 二级索引 。

##### 6.2.5 MySQL中创建和删除索引的语句

InnoDB 和 MyISAM 会自动为主键或者声明为 UNIQUE 的列去自动建立 B+ 树索引，但是如果我们想为其他的列建立索引就需要我们显式的去指明。

我们可以在创建表的时候指定需要建立索引的单个列或者建立联合索引的多个列：

CREATE TALBE 表名 (

 各种列的信息 ··· , 

 [KEY|INDEX] 索引名 (需要被索引的单个列或多个列)

)

其中的 KEY 和 INDEX 是同义词，任意选用一个就可以。我们也可以在修改表结构的时候添加索引：

ALTER TABLE 表名 ADD [INDEX|KEY] 索引名 (需要被索引的单个列或多个列);

比方说我们想在创建 index_demo 表的时候就为 c2 和 c3 列添加一个 联合索引 ，可以这么写建表语句：

```sql
CREATE TABLE index_demo(

 c1 INT,

 c2 INT,

 c3 CHAR(1),

 PRIMARY KEY(c1),

 INDEX idx_c2_c3 (c2, c3)

);
```

​                                  

####  7第7章 好东西也得先学会怎么用-B+树索引的使用

我们前边详细、详细又详细的唠叨了 InnoDB 存储引擎的 B+ 树索引，我们必须熟悉下边这些结论：

* 每个索引都对应一棵 B+ 树， B+ 树分为好多层，最下边一层是叶子节点，其余的是内节点。所有 用户记录都存储在 B+ 树的叶子节点，所有 目录项记录 都存储在内节点。

* InnoDB 存储引擎会自动为主键（如果没有它会自动帮我们添加）建立 聚簇索引 ，聚簇索引的叶子节点包含完整的用户记录。

* 我们可以为自己感兴趣的列建立 二级索引 ， 二级索引 的叶子节点包含的用户记录由 索引列 + 主键 组成，所以如果想通过 二级索引 来查找完整的用户记录的话，需要通过 回表 操作，也就是在通过 二级索引找到主键值之后再到 聚簇索引 中查找完整的用户记录。
* B+ 树中每层节点都是按照索引列值从小到大的顺序排序而组成了双向链表，而且每个页内的记录（不论是用户记录还是目录项记录）都是按照索引列的值从小到大的顺序而形成了一个单链表。如果是 联合索引 的话，则页面和记录先按照 联合索引 前边的列排序，如果该列值相同，再按照 联合索引 后边的列排序。
* 通过索引查找记录是从 B+ 树的根节点开始，一层一层向下搜索。由于每个页面都按照索引列的值建立了Page Directory （页目录），所以在这些页面中的查找非常快。

#### **7.1** **索引的代价**

空间上的代价

这个是显而易见的，每建立一个索引都要为它建立一棵 B+ 树，每一棵 B+ 树的每一个节点都是一个数据页，每个页默认会占用 16KB 的存储空间，一棵很大的 B+ 树由许多数据页组成，那可是很大的一片存储空间呢。

时间上的代价

每次对表中的数据进行增、删、改操作时，都需要去修改各个 B+ 树索引。

```sql
CREATE TABLE person_info(
 id INT NOT NULL auto_increment,
 name VARCHAR(100) NOT NULL,
 birthday DATE NOT NULL,
 phone_number CHAR(11) NOT NULL,
 country varchar(100) NOT NULL,
 PRIMARY KEY (id),
 KEY idx_name_birthday_phone_number (name, birthday, phone_number)
);
```

![image-20240722150038215](D:\desktop\笔记\MySQL数据库\img\sql21.png)

从图中可以看出，这个 idx_name_birthday_phone_number 索引对应的 B+ 树中页面和记录的排序方式就是

这样的：

* 先按照 name 列的值进行排序。

* 如果 name 列的值相同，则按照 birthday 列的值进行排序。

* 如果 birthday 列的值也相同，则按照 phone_number 的值进行排序。

这个排序方式十分、特别、非常、巨、very very very重要，因为只要页面和记录是排好序的，我们就可以通过二分法来快速定位查找。

##### **7.2.1** **全值匹配**

如果我们的搜索条件中的列和索引列一致的话，这种情况就称为全值匹配，比方说下边这个查找语句：

```sql
SELECT * FROM person_info WHERE name = 'Ashburn' AND birthday = '1990-09-27' AND phone_number = '15123983239';
```

##### **7.2.2** **匹配左边的列**

其实在我们的搜索语句中也可以不用包含全部联合索引中的列，只包含左边的就行，比方说下边的查询语句：

```sql
SELECT * FROM person_info WHERE name = 'Ashburn';
```

或者包含多个左边的列也行：

```sql
SELECT * FROM person_info WHERE name = 'Ashburn' AND birthday = '1990-09-27';
```

那为什么搜索条件中必须出现左边的列才可以使用到这个 B+ 树索引呢？比如下边的语句就用不到这个 B+ 树索引么？

```sql
SELECT * FROM person_info WHERE birthday = '1990-09-27';
```

是的，的确用不到，因为 B+ 树的数据页和记录先是按照 name 列的值排序的，在 name 列的值相同的情况下才使用 birthday 列进行排序，也就是说 name 列的值不同的记录中 birthday 的值可能是无序的。

<font  color ='red'>但是需要特别注意的一点是，如果我们想使用联合索引中尽可能多的列，搜索条件中的各个列必须是联合索引中从最左边连续的列。</font>

比方说联合索引 idx_name_birthday_phone_number 中列的定义顺序是 name 、birthday 、 phone_number ，如果我们的搜索条件中只有 name 和 phone_number ，而没有中间的 birthday ，

比方说这样：

```sql
SELECT * FROM person_info WHERE name = 'Ashburn' AND phone_number = '15123983239';
```

这样只能用到 name 列的索引， birthday 和 phone_number 的索引就用不上了，因为 name 值相同的记录先按照birthday 的值进行排序， birthday 值相同的记录才按照 phone_number 值进行排序

###### **7.2.6** **用于排序**

我们在写查询语句的时候经常需要对查询出来的记录通过 ORDER BY 子句按照某种规则进行排序。一般情况下，我们只能把记录都加载到内存中，再用一些排序算法，比如快速排序、归并排序、吧啦吧啦排序等等在内存中对这些记录进行排序，有的时候可能查询的结果集太大以至于不能在内存中进行排序的话，还可能暂时借助磁盘的空间来存放中间结果，排序操作完成后再把排好序的结果集返回到客户端。在 MySQL 中，把这种在内存中或者磁盘上进行排序的方式统称为文件排序（英文名： filesort ），跟 文件 这个词儿一沾边儿，就显得这些排序操作非常慢了（磁盘和内存的速度比起来，就像是飞机和蜗牛的对比）。但是如果 ORDER BY 子句里使用到了我们的索引列，就有可能省去在内存或文件中排序的步骤，比如下边这个简单的查询语句：

```sql
SELECT * FROM person_info ORDER BY name, birthday, phone_number LIMIT 10;
```

这个查询的结果集需要先按照 name 值排序，如果记录的 name 值相同，则需要按照 birthday 来排序，如果birthday 的值相同，则需要按照 phone_number 排序。大家可以回过头去看我们建立的idx_name_birthday_phone_number 索引的示意图，因为这个 B+ 树索引本身就是按照上述规则排好序的，所以直接从索引中提取数据，然后进行 回表 操作取出该索引中不包含的列就好了。简单吧？是的，索引就是这么牛逼。

###### 7.2.6.2不可以使用索引进行排序的几种情况

* **ASC**、**DESC**混用

* **WHERE**子句中出现非排序使用到的索引列

* 排序列包含非同一个索引的列

* 排序列使用了复杂的表达式

#### **7.3** **回表的代价**

```sql
SELECT * FROM person_info WHERE name > 'Asa' AND name < 'Barlow';
```

由于索引 idx_name_birthday_phone_number 对应的 B+ 树中的记录首先会按照 name 列的值进行排序，所以值在 Asa ～ Barlow 之间的记录在磁盘中的存储是相连的，集中分布在一个或几个数据页中，我们可以很快的把这些连着的记录从磁盘中读出来，这种读取方式我们也可以称为 顺序I/O 。根据第1步中获取到的记录的 id 字段的值可能并不相连，而在聚簇索引中记录是根据 id （也就是主键）的顺序排列的，所以根据这些并不连续的 id值到聚簇索引中访问完整的用户记录可能分布在不同的数据页中，这样读取完整的用户记录可能要访问更多的数据页，这种读取方式我们也可以称为 随机I/O 。一般情况下，顺序I/O比随机I/O的性能高很多，所以步骤1的执行可能很快，而步骤2就慢一些。所以这个使用索引 idx_name_birthday_phone_number 的查询有这么两个特点：

* 会使用到两个 B+ 树索引，一个二级索引，一个聚簇索引。

* 访问二级索引使用 顺序I/O ，访问聚簇索引使用 随机I/O 。

<font color ='red'>需要回表的记录越多，使用二级索引的性能就越低，甚至让某些查询宁愿使用全表扫描也不使用 二级索引</font> 。比方说 name 值在 Asa ～ Barlow 之间的用户记录数量占全部记录数量90%以上，那么如果使用idx_name_birthday_phone_number 索引的话，有90%多的 id 值需要回表，这不是吃力不讨好么，还不如直接去扫描聚簇索引（也就是全表扫描）。

那什么时候采用全表扫描的方式，什么时候使用采用 二级索引 + 回表 的方式去执行查询呢？这个就是传说中的查询优化器做的工作，查询优化器会事先对表中的记录计算一些统计数据，然后再利用这些统计数据根据查询的条件来计算一下需要回表的记录数，需要回表的记录数越多，就越倾向于使用全表扫描，反之倾向于使用 二级索引 + 回表 的方式。当然优化器做的分析工作不仅仅是这么简单，但是大致上是个这个过程。一般情况下，限制查询获取较少的记录数会让优化器更倾向于选择使用 二级索引 + 回表 的方式进行查询，因为回表的记录越少，性能提升就越高，比方说上边的查询可以改写成这样：

###### **7.3.1** **覆盖索引**

为了彻底告别 回表 操作带来的性能损耗，我们建议：最好在查询列表里只包含索引列，比如这样：

```sql
SELECT name, birthday, phone_number FROM person_info WHERE name > 'Asa' AND name < 'Barlow'
```

因为我们只查询 name , birthday , phone_number 这三个索引列的值.

#### **7.4** **如何挑选索引**

**7.4.2** **考虑列的基数**

列的基数 指的是某一列中不重复数据的个数，比方说某个列包含值 2, 5, 8, 2, 5, 8, 2, 5, 8 ，虽然有 9 条记录，但该列的基数却是 3 。也就是说，在记录行数一定的情况下，列的基数越大，该列中的值越分散，列的基数越小，该列中的值越集中。。所以结论就是：最好为那些列的基数大的列建立索引，为基数太小列的建立索引效果可能不好。

##### **7.4.3** **索引列的类型尽量小**

我们这里所说的 类型大小 指的就是该类型表示的数据范围的大小。能表示的整数范围当然也是依次递增，如果我们想要对某个整数列建立索引的话，在表示的整数范围允许的情况下，尽量让索引列使用较小的类型，比如我们能使用 INT 就不要使用 BIGINT ，能使用 MEDIUMINT 就不要使用INT ～ 这是因为：

* 数据类型越小，在查询时进行的比较操作越快（这是CPU层次的东东）

* 数据类型越小，索引占用的存储空间就越少，在一个数据页内就可以放下更多的记录，从而减少磁盘 I/O 带的性能损耗，也就意味着可以把更多的数据页缓存在内存中，从而加快读写效率。

###### **7.4.4** **索引字符串值的前缀**

只对字符串的前几个字符进行索引也就是说在二级索引的记录中只保留字符串前几个字符。这样在查找记录时虽然不能精确的定位

到记录的位置，但是能定位到相应前缀所在的位置，然后根据前缀相同的记录的主键值回表查询完整的字符串值，再对比就好了。这样只在 B+ 树中存储字符串的前几个字符的编码，既节约空间，又减少了字符串的比较时间，还大概能解决排序的问题，何乐而不为，比方说我们在建表语句中只对 name 列的前10个字符进行索引可以这么写：

```sql
CREATE TABLE person_info(

 name VARCHAR(100) NOT NULL,

 birthday DATE NOT NULL,

 phone_number CHAR(11) NOT NULL,

 country varchar(100) NOT NULL,

 KEY idx_name_birthday_phone_number (name(10), birthday, phone_number)

); 
```

name(10) 就表示在建立的 B+ 树索引中只保留记录的前 10 个字符的编码，这种只索引字符串值的前缀的策略是我们非常鼓励的，尤其是在字符串类型能存储的字符比较多的时候。

##### **7.4.5** **让索引列在比较表达式中单独出现**

假设表中有一个整数列 my_col ，我们为这个列建立了索引。下边的两个 WHERE 子句虽然语义是一致的，但是在效率上却有差别：

* \1. WHERE my_col * 2 < 4

* \2. WHERE my_col < 4/2

第1个 WHERE 子句中 my_col 列并不是以单独列的形式出现的，而是以 my_col * 2 这样的表达式的形式出现的，存储引擎会依次遍历所有的记录，计算这个表达式的值是不是小于 4 ，所以这种情况下是使用不到为 my_col 列建立的 B+ 树索引的。而第2个 WHERE 子句中 my_col 列并是以单独列的形式出现的，这样的情况可以直接使用B+ 树索引。

<font color = 'red'>所以结论就是：如果索引列在比较表达式中不是以单独列的形式出现，而是以某个表达式，或者函数调用形式出现的话，是用不到索引的。</font>

#### **7.5** **总结**

上边只是我们在创建和使用 B+ 树索引的过程中需要注意的一些点，后边我们还会陆续介绍更多的优化方法和注意事项，敬请期待。本集内容总结如下：

* \1. B+ 树索引在空间和时间上都有代价，所以没事儿别瞎建索引。

* \2. B+ 树索引适用于下边这些情况
* * 全值匹配
* * 匹配左边的列
* * 匹配范围值
* * 精确匹配某一列并范围匹配另外一列
* * 用于排序
* * 用于分组
* \3. 在使用索引时需要注意下边这些事项：
* * 只为用于搜索、排序或分组的列创建索引
* * 为列的基数大的列创建索引
* * 索引列的类型尽量小
* * 可以只对字符串值的前缀建立索引
* * 只有索引列在比较表达式中单独出现才可以适用索引
* * 为了尽可能少的让 聚簇索引 发生页面分裂和记录移位的情况，建议让主键拥有 AUTO_INCREMENT 属性。
* * 定位并删除表中的重复和冗余索引
* * 尽量使用 覆盖索引 进行查询，避免 回表 带来的性能损耗

### 第8章 数据的家-MySQL的数据目录

####  8.3 **数据目录的结构**

##### **8.3.1** **数据库在文件系统中的表示**

每当我们使用 CREATE DATABASE 数据库名 语句创建一个数据库的时候，在文件系统上实际发生了什么呢？其实

很简单，<font color = 'red'>每个数据库都对应数据目录下的一个子目录，或者说对应一个文件夹</font>，我们每当我们新建一个数据库

时， MySQL 会帮我们做这两件事儿：

* \1. 在 数据目录 下创建一个和数据库名同名的子目录（或者说是文件夹）。

* \2. 在该与数据库名同名的子目录下创建一个名为 db.opt 的文件，这个文件中包含了该数据库的各种属性，比方说该数据库的字符集和比较规则是个啥

##### **8.3.2** **表在文件系统中的表示**

我们的数据其实都是以记录的形式插入到表中的，每个表的信息其实可以分为两种：

* \1. 表结构的定义

* \2. 表中的数据

比方说我们在 dahaizi 数据库下创建一个名为 test 的表：这个后缀名为.frm是以二进制格式存储的，我们直接打开会是乱码的～

###### **8.3.2.1 InnoDB****是如何存储表数据的**

InnoDB 其实是使用 页 为基本单位来管理存储空间的，默认的 页 大小为 16KB 。

对于 InnoDB 存储引擎来说，每个索引都对应着一棵 B+ 树，该 B+ 树的每个节点都是一个数据页，数据页之间不必要是物理连续的，因为数据页之间有 双向链表 来维护着这些页的顺序。

InnoDB 的聚簇索引的叶子节点存储了完整的用户记录，也就是所谓的索引即数据，数据即索引。

为了更好的管理这些页，设计 InnoDB 的大叔们提出了一个 表空间 或者 文件空间 （英文名： table space 或者 file space ）的概念，这个表空间是一个抽象的概念，它可以对应文件系统上一个或多个真实文件（不同表空间对应的文件数量可能不同）。每一个 表空间 可以被划分为很多很多很多个 页 ，我们的表数据就存放在某个 表空间 下的某些页里。设计 InnoDB 的大叔将表空间划分为几种不同的类型，

###### 系统表空间（**system tablespace**）

这个所谓的 系统表空间 可以对应文件系统上一个或多个实际的文件，默认情况下， InnoDB 会在 数据目录 下创建一个名为 ibdata1 （在你的数据目录下找找看有木有）、大小为 12M 的文件，这个文件就是对应的 系统表空间 在文件系统上的表示.从MySQL5.5.7到MySQL5.6.6之间的各个版本中，我们表中的数据都会被默认存储到这个 系统表空间。

###### 独立表空间**(file-per-table tablespace)**

在MySQL5.6.6以及之后的版本中， InnoDB 并不会默认的把各个表的数据存储到系统表空间中，而是为每一个表建立一个独立表空间，也就是说我们创建了多少个表，就有多少个独立表空间。使用 独立表空间 来存储表数据的话，会在该表所属数据库对应的子目录下创建一个表示该 独立表空间 的文件，文件名和表名相同，只不过添加了一个 .ibd 的扩展名而已

比方说假如我们使用了 独立表空间 去存储 xiaohaizi 数据库下的 test 表的话，那么在该表所在数据库对应的xiaohaizi 目录下会为 test 表创建这两个文件：

* test.frm

* test.ibd

其中 test.ibd 文件就用来存储 test 表中的数据和索引。当然我们也可以自己指定使用 系统表空间 还是 独立表空间 来存储数据，这个功能由启动参数 innodb_file_per_table 控制。

在还新提出了一些不同类型的表空间，比如通用表空间（general tablespace）、undo表空间（undo tablespace）、临时表空间（temporary tablespace）

###### **8.3.2.2 MyISAM**是如何存储表数据的

而且和 InnoDB 不同的是， MyISAM 并没有什么所谓的 表空间 一说，表数据都存放到对应的数据库子目录下。假如 test 表使用 MyISAM 存储引擎的话，那么在它所在数据库对应的 xiaohaizi 目录下会为 test 表创建这三个文件：

* test.frm

* test.MYD

* test.MYI

  其中 test.MYD 代表表的数据文件，也就是我们插入的用户记录； test.MYI 代表表的索引文件，我们为该表创建

的索引都会放到这个文件中。

##### **8.3.3** **视图在文件系统中的表示**

我们知道 MySQL 中的视图其实是虚拟的表，也就是某个查询语句的一个别名而已，所以在存储 视图 的时候是不需要存储真实的数据的，只需要把它的结构存储起来就行了。和 表 一样，描述视图结构的文件也会被存储到所属数据库对应的子目录下边，只会存储一个 视图名.frm 的文件。

##### **8.3.4** **其他的文件**

除了我们上边说的这些用户自己存储的数据以外， 数据目录 下还包括为了更好运行程序的一些额外文件，主要

包括这几种类型的文件：

* 服务器进程文件。
* 我们知道每运行一个 MySQL 服务器程序，都意味着启动一个进程。 MySQL 服务器会把自己的进程ID写入到一

个文件中。

* 服务器日志文件。
* 在服务器运行过程中，会产生各种各样的日志，比如常规的查询日志、错误日志、二进制日志、redo日志吧啦吧啦各种日志，这些日志各有各的用途，我们之后会重点唠叨各种日志的用途，现在先了解一下就可以
* 默认/自动生成的SSL和RSA证书和密钥文件。
* 主要是为了客户端和服务器安全通信而创建的一些文件

### **8.5 MySQL****系统数据库简介**

我们前边提到了MySQL的几个系统数据库，这几个数据库包含了MySQL服务器运行过程中所需的一些信息以及一些运行状态信息，我们现在稍微了解一下。

* mysql
* 这个数据库贼核心，它存储了MySQL的用户账户和权限信息，一些存储过程、事件的定义信息，一些运行过程中产生的日志信息，一些帮助信息以及时区信息等。
* information_schema
* 这个数据库保存着MySQL服务器维护的所有其他数据库的信息，比如有哪些表、哪些视图、哪些触发器、哪些列、哪些索引吧啦吧啦。这些信息并不是真实的用户数据，而是一些描述性信息，有时候也称之为元数据。
* performance_schema
* 这个数据库里主要保存MySQL服务器运行过程中的一些状态信息，算是对MySQL服务器的一个性能监控。包括统计最近执行了哪些语句，在执行过程的每个阶段都花费了多长时间，内存的使用情况等等信息。
* sys
* 这个数据库主要是通过视图的形式把 information_schema 和 performance_schema 结合起来，让程序员可以更方便的了解MySQL服务器的一些性能信息

###  9 第9章 存放页面的大池子-InnoDB的表空间

![image-20240723112818108](D:\desktop\笔记\MySQL数据库\img\sql22.png)

![image-20240723113048647](D:\desktop\笔记\MySQL数据库\img\sql23.png)

从上图中可以看出，任何类型的页都会包含这两个部分：

* File Header ：记录页面的一些通用信息

* File Trailer ：校验页是否完整，保证从内存到磁盘刷新时内容的一致性

![image-20240723113229039](D:\desktop\笔记\MySQL数据库\img\sql24.png)

现在除了名称里边儿带有 LSN 的两个字段大家可能看不懂以外，其他的字段肯定都是倍儿熟了，不过我们仍要强调这么几点：

* 表空间中的每一个页都对应着一个页号，也就是 FIL_PAGE_OFFSET ，这个页号由4个字节组成，也就是32个比特位，所以一个表空间最多可以拥有2³²个页，如果按照页的默认大小16KB来算，一个表空间最多支持64TB的数据。表空间的第一个页的页号为0，之后的页号分别是1，2，3...依此类推

* 某些类型的页可以组成链表，链表中的页可以不按照物理顺序存储，而是根据 FIL_PAGE_PREV 和FIL_PAGE_NEXT 来存储上一个页和下一个页的页号。需要注意的是，这两个字段主要是为了 INDEX 类型的页，也就是我们之前一直说的数据页建立 B+ 树后，为每层节点建立双向链表用的，一般类型的页是不使用这两个字段的。

* 每个页的类型由 FIL_PAGE_TYPE 表示，比如像数据页的该字段的值就是 0x45BF ，我们后边会介绍各种不同类型的页，不同类型的页在该字段上的值是不同的。

### **9.2** **独立表空间结构**

我们知道 InnoDB 支持许多种类型的表空间，本章重点关注独立表空间和系统表空间的结构。它们的结构比较相似，但是由于系统表空间中额外包含了一些关于整个系统的信息，所以我们先挑简单一点的独立表空间来唠叨，稍后再说系统表空间的结构。

#### **9.2.1** **区（**extent）的概念

表空间中的页实在是太多了，为了更好的管理这些页面，设计 InnoDB 的大叔们提出了 区 （英文名： extent ）的概念。对于16KB的页来说，连续的64个页就是一个 区 ，也就是说一个区默认占用1MB空间大小。不论是系统表空间还是独立表空间，都可以看成是由若干个区组成的，每256个区被划分成一组。画个图表示就是这样：

![image-20240723113844185](D:\desktop\笔记\MySQL数据库\img\sql25.png)

### **9.2.2** **段（**segment）的概念

引入了 区 （ extent ）的概念，一个区就是在物理位置上连续的64个页。在表中数据量大的时候，为某个索引分配空间的时候就不再按照页为单位分配了，而是按照 区 为单位分配，甚至在表中的数据十分非常特别多的时候，可以一次性分配多个连续的区。虽然可能造成一点点空间的浪费（数据不足填充满整个区），但是从性能角度看，可以消除很多的随机 I/O ，功大于过嘛！

以设计 InnoDB 的大叔们对 B+ 树的叶子节点和非叶子节点进行了区别对待，也就是说叶子节点有自己独有的 区 ，非叶子节点也有自己独有的 区 。存放叶子节点的区的集合就算是一个 段 （ segment ），存放非叶子节点的区的集合也算是一个 段 。也就是说一个索引会生成2个段，一个叶子节点段，一个非叶子节点段。

现在为了考虑以完整的区为单位分配

给某个段对于数据量较小的表太浪费存储空间的这种情况，设计 InnoDB 的大叔们提出了一个碎片（fragment）区的概念，也就是在一个碎片区中，并不是所有的页都是为了存储同一个段的数据而存在的，而是碎片区中的页可以用于不同的目的，比如有些页用于段A，有些页用于段B，有些页甚至哪个段都不属于。碎片区直属于表空间，并不属于任何一个段。所以此后为某个段分配存储空间的策略是这样的：

* 在刚开始向表中插入数据的时候，段是从某个碎片区以单个页面为单位来分配存储空间的。

* 当某个段已经占用了32个碎片区页面之后，就会以完整的区为单位来分配存储空间。

##### **9.2.3** **区的分类**

通过上边一通唠叨，大家知道了表空间的是由若干个区组成的，这些区大体上可以分为4种类型：

* 空闲的区：现在还没有用到这个区中的任何页面。有剩余空间的碎片区：表示碎片区中还有可用的页面。
* 没有剩余空间的碎片区：表示碎片区中的所有页面都被使用，没有空闲页面。
* 附属于某个段的区。每一个索引都可以分为叶子节点段和非叶子节点段，除此之外InnoDB还会另外定义一些
* A特殊作用的段，在这些段中的数据量很大时将使用区来作为基本的分配单位

![image-20240723132347090](D:\desktop\笔记\MySQL数据库\img\sql26.png)

为了方便管理这些区，设计 InnoDB 的大叔设计了一个称为 XDES Entry 的结构（全称就是Extent DescriptorEntry），每一个区都对应着一个 XDES Entry 结构，这个结构记录了对应的区的一些属性。我们先看图来对这个结构有个大致的了解：

![image-20240723132503326](D:\desktop\笔记\MySQL数据库\img\sql27.png)

###### **9.2.3.1 XDES Entry****链表**

现在的问题是你怎么知道表空间里的哪些区是 FREE 的，哪些区的状态是 FREE_FRAG 的，哪些区是FULL_FRAG 的？要知道表空间的大小是可以不断增大的，当增长到GB级别的时候，区的数量也就上千了，我们总不能每次都遍历这些区对应的 XDES Entry 结构吧？这时候就是 XDES Entry 中的 List Node 部分发挥奇效的时候了，我们可以通过 List Node 中的指针，做这么三件事：

* 把状态为 FREE 的区对应的 XDES Entry 结构通过 List Node 来连接成一个链表，这个链表我们就称之为 FREE 链表。
* 把状态为 FREE_FRAG 的区对应的 XDES Entry 结构通过 List Node 来连接成一个链表，这个链表我们就称之为 FREE_FRAG 链表。
* 把状态为 FULL_FRAG 的区对应的 XDES Entry 结构通过 List Node 来连接成一个链表，这个链表我们就称之为 FULL_FRAG 链表。

一个段中可以有好多个区，有的区是完全

空闲的，有的区还有一些页面可以用，有的区已经没有空闲页面可以用了，所以我们有必要继续细分，设计InnoDB 的大叔们为每个段中的区对应的 XDES Entry 结构建立了三个链表：

* FREE 链表：同一个段中，所有页面都是空闲的区对应的 XDES Entry 结构会被加入到这个链表。注意和直属于表空间的 FREE 链表区别开了，此处的 FREE 链表是附属于某个段的。
* NOT_FULL 链表：同一个段中，仍有空闲空间的区对应的 XDES Entry 结构会被加入到这个链表。
* FULL 链表：同一个段中，已经没有空闲空间的区对应的 XDES Entry 结构会被加入到这个链表。

再次强调一遍，每一个索引都对应两个段，每个段都会维护上述的3个链表，比如下边这个表：

```sql
CREATE TABLE t (

 c1 INT NOT NULL AUTO_INCREMENT,

 c2 VARCHAR(100),

 c3 VARCHAR(100),

 PRIMARY KEY (c1),

 KEY idx_c2 (c2)

)ENGINE=InnoDB;
```

这个表 t 共有两个索引，一个聚簇索引，一个二级索引 idx_c2 ，所以这个表共有4个段，每个段都会维护上述3个链表，总共是12个链表，加上我们上边说过的直属于表空间的3个链表，整个独立表空间共需要维护15个链表。

###### **9.2.3.3** **链表小结**

综上所述，表空间是由若干个区组成的，每个区都对应一个 XDES Entry 的结构，直属于表空间的区对应的 XDESEntry 结构可以分成 FREE 、 FREE_FRAG 和 FULL_FRAG 这3个链表；每个段可以附属若干个区，每个段中的区对应的 XDES Entry 结构可以分成 FREE 、 NOT_FULL 和 FULL 这3个链表。每个链表都对应一个 List Base Node 的结构，这个结构里记录了链表的头、尾节点的位置以及该链表中包含的节点数。正是因为这些链表的存在，管理这些区才变成了一件so easy的事情。

### **9.3** **系统表空间**

MySQL除了保存着我们插入的用户数据之外，还需要保存许多额外的信息，比方说：

某个表属于哪个表空间，表里边有多少列表对应的每一个列的类型是什么该表有多少索引，每个索引对应哪几个字段，该索引对应的根页面在哪个表空间的哪个页面该表有哪些外键，外键对应哪个表的哪些列某个表空间对应文件系统上文件路径是什么balabala ... 还有好多，不一一列举了

上述这些数据并不是我们使用 INSERT 语句插入的用户数据，实际上是为了更好的管理我们这些用户数据而不得已引入的一些额外数据，这些数据也称为 元数据 。InnoDB存储引擎特意定义了一些列的内部系统表（internalsystem table）来记录这些这些 元数据 ：

![image-20240723144453676](D:\desktop\笔记\MySQL数据库\img\sql28.png)

这些系统表也被称为 数据字典 ，它们都是以 B+ 树的形式保存在系统表空间的某些页面中，其中SYS_TABLES 、 SYS_COLUMNS 、 SYS_INDEXES 、 SYS_FIELDS 这四个表尤其重要，称之为基本系统表（basicsystem tables），我们先看看这4个表的结构：

![image-20240723145725608](D:\desktop\笔记\MySQL数据库\img\sql29.png)

### **10** **第****10****章 条条大路通罗马****-****单表访问方法**

```sql
CREATE TABLE single_table (

 id INT NOT NULL AUTO_INCREMENT,

 key1 VARCHAR(100),

 key2 INT,

 key3 VARCHAR(100),

 key_part1 VARCHAR(100),

 key_part2 VARCHAR(100),

 key_part3 VARCHAR(100),

 common_field VARCHAR(100),

 PRIMARY KEY (id),

 KEY idx_key1 (key1),

 UNIQUE KEY idx_key2 (key2),

 KEY idx_key3 (key3),

 KEY idx_key_part(key_part1, key_part2, key_part3)

) Engine=InnoDB CHARSET=utf8;
```

设计MySQL的大叔把查询的执行方式大致分为下边两种：

* 使用全表扫描进行查询
* 这种执行方式很好理解，就是把表的每一行记录都扫一遍嘛，把符合搜索条件的记录加入到结果集就完了。不管是啥查询都可以使用这种方式执行，当然，这种也是最笨的执行方式。

* 使用索引进行查询

* * 针对主键或唯一二级索引的等值查询

    针对普通二级索引的等值查询

    针对索引列的范围查询

    直接扫描整个索引

#### **10.2 const**

有的时候我们可以通过主键列来定位一条记录，比方说这个查询：

```sql
SELECT * FROM single_table WHERE id = 1438;
```

设计 MySQL 的大叔认为通过主键或者唯一二级索引列与常数的等值比较来定位一条记录是像坐火箭一样快的，所以他们把这种通过主键或者唯一二级索引列来定位一条记录的访问方法定义为： const ，意思是常数级别的，代价是可以忽略不计的。不过这种 const 访问方法只能在主键列或者唯一二级索引列和一个常数进行等值比较时才有效，如果主键或者唯一二级索引是由多个列构成的话，索引中的每一个列都需要与常数进行等值比较，这个const 访问方法才有效（这是因为只有该索引中全部列都采用等值比较才可以定位唯一的一条记录）。

#### **10.3 ref**

有时候我们对某个普通的二级索引列与常数进行等值比较，比如这样：

```sql
SELECT * FROM single_table WHERE key1 = 'abc';
```

对于这个查询，我们当然可以选择全表扫描来逐一对比搜索条件是否满足要求，我们也可以先使用二级索引找到对应记录的 id 值，然后再回表到聚簇索引中查找完整的用户记录。由于普通二级索引并不限制索引列值的唯一性，所以可能找到多条对应的记录，也就是说使用二级索引来执行查询的代价取决于等值匹配到的二级索引记录条数。如果匹配的记录较少，则回表的代价还是比较低的，MySQL 可能选择使用索引而不是全表扫描的方式来执行查询。设计 MySQL 的大叔就把这种搜索条件为二级索引列与常数等值比较，采用二级索引来执行查询的访问方法称为： ref 。

#### **10.4 ref_or_null**

有时候我们不仅想找出某个二级索引列的值等于某个常数的记录，还想把该列的值为 NULL 的记录也找出来，就像下边这个查询：

```sql
SELECT * FROM single_demo WHERE key1 = 'abc' OR key1 IS NULL;
```

当使用二级索引而不是全表扫描的方式执行该查询时，这种类型的查询使用的访问方法就称为ref_or_null 。

#### **10.5 range**

我们之前介绍的几种访问方法都是在对索引列与某一个常数进行等值比较的时候才可能使用到（ ref_or_null 比较奇特，还计算了值为 NULL 的情况），但是有时候我们面对的搜索条件更复杂，比如下边这个查询：

```sql
SELECT * FROM single_table WHERE key2 IN (1438, 6328) OR (key2 >= 38 AND key2 <= 79);
```

我们当然还可以使用全表扫描的方式来执行这个查询，不过也可以使用 二级索引 + 回表 的方式执行，如果采用 二级索引 + 回表 的方式来执行的话，那么此时的搜索条件就不只是要求索引列与常数的等值匹配了，而是索引列需要匹配某个或某些范围的值，在本查询中 key2 列的值只要匹配下列3个范围中的任何一个就算是匹配成功

#### **10.6 index**

看下边这个查询：

```sql
SELECT key_part1, key_part2, key_part3 FROM single_table WHERE key_part2 = 'abc';
```

由于 key_part2 并不是联合索引 idx_key_part 最左索引列，所以我们无法使用 ref 或者 range 访问方法来执行这个语句。但是这个查询符合下边这两个条件：

* 它的查询列表只有3个列： key_part1 , key_part2 , key_part3 ，而索引 idx_key_part 又包含这三个列。
* 搜索条件中只有 key_part2 列。这个列也包含在索引 idx_key_part 中。

也就是说我们可以直接通过遍历 idx_key_part 索引的叶子节点的记录来比较 key_part2 = 'abc' 这个条件是否成立，把匹配成功的二级索引记录的 key_part1 , key_part2 , key_part3 列的值直接加到结果集中就行了。

#### **10.7 all**

最直接的查询执行方式就是我们已经提了无数遍的全表扫描，对于 InnoDB 表来说也就是直接扫描聚簇索引，设计 MySQL 的大叔把这种使用全表扫描执行查询的方式称之为： all 。

##### **10.8.1** **重温 二级索引** **+** **回表**

一般情况下只能利用单个二级索引执行查询，比方说下边的这个查询：

```sql
SELECT * FROM single_table WHERE key1 = 'abc' AND key2 > 1000;
```

查询优化器会识别到这个查询中的两个搜索条件：

* key1 = 'abc'
* key2 > 1000

优化器一般会根据 single_table 表的统计数据来判断到底使用哪个条件到对应的二级索引中查询扫描的行数会更少，选择那个扫描行数较少的条件到对应的二级索引中查询（关于如何比较的细节我们后边的章节中会唠叨）。然后将从该二级索引中查询到的结果经过回表得到完整的用户记录后再根据其余的 WHERE 条件过滤记录。一般来说，等值查找比范围查找需要扫描的行数更少（也就是 ref 的访问方法一般比 range 好，但这也不总是一定的，也可能采用 ref 访问方法的那个索引列的值为特定值的行数特别多），所以这里假设优化器决定使用idx_key1 索引进行查询，那么整个查询过程可以分为两个步骤：

* 步骤1：使用二级索引定位记录的阶段，也就是根据条件 key1 = 'abc' 从 idx_key1 索引代表的 B+ 树中找到对应的二级索引记录。
* 步骤2：回表阶段，也就是根据上一步骤中找到的记录的主键值进行 回表 操作，也就是到聚簇索引中找到对应的完整的用户记录，再根据条件 key2 > 1000 到完整的用户记录继续过滤。将最终符合过滤条件的记录返回给用户。

<font color ='red'> 因为二级索引的节点中的记录只包含索引列和主键，所以在步骤1中使用idx_key1 索引进行查询时只会用到与 key1 列有关的搜索条件，其余条件，比如 key2 > 1000 这个条件在步骤1中是用不到的，只有在步骤2完成回表操作后才能继续针对完整的用户记录中继续过滤</font>

######  10.8.2.2** **有的搜索条件无法使用索引的情况**

比如下边这个查询：

```sql
SELECT * FROM single_table WHERE key2 > 100 AND common_field = 'abc';
```

请注意，这个查询语句中能利用的索引只有 idx_key2 一个，而 idx_key2 这个二级索引的记录中又不包含common_field 这个字段，所以在使用二级索引 idx_key2 定位记录的阶段用不到 common_field = 'abc' 这个条件，这个条件是在回表获取了完整的用户记录后才使用的，而 范围区间 是为了到索引中取记录中提出的概念，所以在确定 范围区间 的时候不需要考虑 common_field = 'abc' 这个条件，我们在为某个索引确定范围区间的时候只需要把用不到相关索引的搜索条件替换为 TRUE 就好了。

同理，我们把使用不到 idx_key2 索引的搜索条件替换为 TRUE ：

```sql
SELECT * FROM single_table WHERE key2 > 100 OR TRUE;
```

接着化简：

```sql
SELECT * FROM single_table WHERE TRUE;
```

额，这也就说说明如果我们强制使用 idx_key2 执行查询的话，对应的范围区间就是 (-∞, +∞) ，也就是需要将全部二级索引的记录进行回表，这个代价肯定比直接全表扫描都大了。也就是说一个使用到索引的搜索条件和没有使用该索引的搜索条件使用 OR 连接起来后是无法使用该索引的。

##### **10.8.3** **索引合并**

我们前边说过 MySQL 在一般情况下执行一个查询时最多只会用到单个二级索引，但不是还有特殊情况么，在这些特殊情况下也可能在一个查询中使用到多个二级索引，设计 MySQL 的大叔把这种使用到多个索引来完成一次查询的执行方法称之为： index merge ，具体的索引合并算法有下边三种。

**10.8.3.1 Intersection****合并**

Intersection 翻译过来的意思是 交集 。这里是说某个查询可以使用多个二级索引，将从多个二级索引中查询到的结果取交集，比方说下边这个查询：

```sql
SELECT * FROM single_table WHERE key1 = 'a' AND key3 = 'b';
```

假设这个查询使用 Intersection 合并的方式执行的话，那这个过程就是这样的：

* 从 idx_key1 二级索引对应的 B+ 树中取出 key1 = 'a' 的相关记录。从 idx_key3 二级索引对应的 B+ 树中取出 key3 = 'b' 的相关记录。

* 二级索引的记录都是由 索引列 + 主键 构成的，所以我们可以计算出这两个结果集中 id 值的交集。

* 按照上一步生成的 id 值列表进行回表操作，也就是从聚簇索引中把指定 id 值的完整用户记录取出来，返回给用户。

###### **10.8.3.2 Union****合并**

Intersection 是交集的意思，这适用于使用不同索引的搜索条件之间使用 AND 连接起来的情况； Union 是并集的意思，适用于使用不同索引的搜索条件之间使用 OR 连接起来的情况。与 Intersection 索引合并类似，MySQL 在某些特定的情况下才可能会使用到 Union 索引合并：

* 情况一：二级索引列是等值匹配的情况，对于联合索引来说，在联合索引中的每个列都必须等值匹配，不能出现只出现匹配部分列的情况。

而下边这两个查询就不能进行 Union 索引合并：

```sql
 SELECT * FROM single_table WHERE key1 > 'a' OR (key_part1 = 'a' AND key_part2 = 'b'

AND key_part3 = 'c');

 SELECT * FROM single_table WHERE key1 = 'a' OR key_part1 = 'a';
```

第一个查询是因为对 key1 进行了范围匹配，第二个查询是因为联合索引 idx_key_part 中的 key_part2 列并没有出现在搜索条件中，所以这两个查询不能进行 Union 索引合并。

* 情况二：主键列可以是范围匹配

* 情况三：使用 Intersection 索引合并的搜索条件

这种情况其实也挺好理解，就是搜索条件的某些部分使用 Intersection 索引合并的方式得到的主键集合和其他方式得到的主键集合取交集，比方说这个查询：

```sql
 SELECT * FROM single_table WHERE key_part1 = 'a' AND key_part2 = 'b' AND key_part3 =

'c' OR (key1 = 'a' AND key3 = 'b');
```

优化器可能采用这样的方式来执行这个查询：

* 先按照搜索条件 key1 = 'a' AND key3 = 'b' 从索引 idx_key1 和 idx_key3 中使用 Intersection 索引合并的方式得到一个主键集合。
* 再按照搜索条件 key_part1 = 'a' AND key_part2 = 'b' AND key_part3 = 'c' 从联合索引idx_key_part 中得到另一个主键集合。
* 采用 Union 索引合并的方式把上述两个主键集合取并集，然后进行回表操作，将结果返回给用户

######    **10.8.3.3 Sort-Union****合并**

Union 索引合并的使用条件太苛刻，必须保证各个二级索引列在进行等值匹配的条件下才可能被用到，比方说下

边这个查询就无法使用到 Union 索引合并：

```sql
SELECT * FROM single_table WHERE key1 < 'a' OR key3 > 'z'
```

这是因为根据 key1 < 'a' 从 idx_key1 索引中获取的二级索引记录的主键值不是排好序的，根据 key3 >'z' 从 idx_key3 索引中获取的二级索引记录的主键值也不是排好序的，但是 key1 < 'a' 和 key3 > 'z' 这两个条件又特别让我们动心，所以我们可以这样：

* 先根据 key1 < 'a' 条件从 idx_key1 二级索引总获取记录，并按照记录的主键值进行排序

* 再根据 key3 > 'z' 条件从 idx_key3 二级索引总获取记录，并按照记录的主键值进行排序

* 因为上述的两个二级索引主键值都是排好序的，剩下的操作和 Union 索引合并方式就一样了。

我们把上述这种先按照二级索引记录的主键值进行排序，之后按照 Union 索引合并方式执行的方式称之为 SortUnion 索引合并，很显然，这种 Sort-Union 索引合并比单纯的 Union 索引合并多了一步对二级索引记录的主键值排序的过程

#### **11** **第****11****章 两个表的亲密接触****-****连接的原理**

##### **11.1** **连接简介**

###### **11.1.1** **连接的本质**

连接 的本质就是把各个连接表中的记录都取出来依次匹配的组合加入结果集并返回给用户。所以我们把 t1 和t2 两个表连接起来的过程如下图所示

![image-20240724141110838](D:\desktop\笔记\MySQL数据库\img\sql30.png)

连接查询的结果集中包含一个表中的每一条记录与另一个表中的每一条记录相互匹配的组合，像这样的结果集就可以称之为 笛卡尔积 。

下边我们就要看一下携带过滤条件的连接查询的大致执行过程了，比方说下边这个查询语句：

```sql
SELECT * FROM t1, t2 WHERE t1.m1 > 1 AND t1.m1 = t2.m2 AND t2.n2 < 'd';
```

在这个查询中我们指明了这三个过滤条件：

* t1.m1 > 1
* t1.m1 = t2.m2
* t2.n2 < 'd'

那么这个连接查询的大致执行过程如下：

\1. 首先确定第一个需要查询的表，这个表称之为 驱动表 。

我们可以看到， t1 表中符合 t1.m1 > 1 的记录有两条。

\2. 针对上一步骤中从驱动表产生的结果集中的每一条记录，分别需要到 t2 表中查找匹配的记录，所谓 匹配的记录 ，指的是符合过滤条件的记录。因为是根据 t1 表中的记录去找 t2 表中的记录，所以 t2 表也可以被称之为 被驱动表 。上一步骤从驱动表中得到了2条记录，所以需要查询2次 t2 表。A

![image-20240724141817371](D:\desktop\笔记\MySQL数据库\img\sql31.png)

从上边两个步骤可以看出来，我们上边唠叨的这个两表连接查询共需要查询1次 t1 表，2次 t2 表。当然这是在特定的过滤条件下的结果，如果我们把 t1.m1 > 1 这个条件去掉，那么从 t1 表中查出的记录就有3条，就需要查询3次 t2 表了。也就是说在两表连接查询中，驱动表只需要访问一次，被驱动表可能被访问多次。

![image-20240724142408651](D:\desktop\笔记\MySQL数据库\img\sql32.png)

从上述查询结果中我们可以看到，各个同学对应的各科成绩就都被查出来了，可是有个问题， 史珍香 同学，也就是学号为 20180103 的同学因为某些原因没有参加考试，所以在 score 表中没有对应的成绩记录。那如果老师想查看所有同学的考试成绩，即使是缺考的同学也应该展示出来，但是到目前为止我们介绍的 连接查询 是无法

完成这样的需求的。我们稍微思考一下这个需求，<font color ='red'>其本质是想：驱动表中的记录即使在被驱动表中没有匹配的记录，也仍然需要加入到结果集。</font>为了解决这个问题，就有了 内连接 和 外连接 的概念：

* 对于 内连接 的两个表，驱动表中的记录在被驱动表中找不到匹配的记录，该记录不会加入到最后的结果集，我们上边提到的连接都是所谓的 内连接 。
* 对于 外连接 的两个表，驱动表中的记录即使在被驱动表中没有匹配的记录，也仍然需要加入到结果集。

在 MySQL 中，根据选取驱动表的不同，外连接仍然可以细分为2种：

* 左外连接:选取左侧的表为驱动表。
* 右外连接:选取右侧的表为驱动表

<font color = 'red'>对于左（外）连接和右（外）连接来说，必须使用 ON 子句来指出连接条件。</font>

###### **11.1.3.3** **内连接的语法**

也就是说在 MySQL 中，下边这几种内连接的写法都是等价的：

```sql
SELECT * FROM t1 JOIN t2;

SELECT * FROM t1 INNER JOIN t2;

SELECT * FROM t1 CROSS JOIN t2;
```

上边的这些写法和直接把需要连接的表名放到 FROM 语句之后，用逗号 , 分隔开的写法是等价的：

```sql
SELECT * FROM t1, t2;
```

现在我们虽然介绍了很多种 内连接 的书写方式，不过熟悉一种就好了，这里我们推荐 INNER JOIN 的形式书写内连接（因为 INNER JOIN 语义很明确嘛，可以和 LEFT JOIN 和 RIGHT JOIN 很轻松的区分开）。这里需要注意的是，由于在内连接中ON子句和WHERE子句是等价的，所以内连接中不要求强制写明ON子句。

#### **11.2** **连接的原理**

##### **11.2.1** **嵌套循环连接（****Nested-Loop Join****）**

我们前边说过，对于两表连接来说，驱动表只会被访问一遍，但被驱动表却要被访问到好多遍，具体访问几遍取

决于对驱动表执行单表查询后的结果集中的记录条数。对于内

```
for each row in t1 { #此处表示遍历满足对t1单表查询结果集中的每一条记录

 for each row in t2 { #此处表示对于某条t1表的记录来说，遍历满足对t2单表查询结果集中的

每一条记录

 for each row in t3 { #此处表示对于某条t1和t2表的记录组合来说，对t3表进行单表查询

 if row satisfies join conditions, send to client

 }

 }

}
```

这个过程就像是一个嵌套的循环，所以这种驱动表只访问一次，但被驱动表却可能被多次访问，访问次数取决于对驱动表执行单表查询后的结果集中的记录条数的连接执行方式称之为 嵌套循环连接 （ Nested-Loop Join ），这是最简单，也是最笨拙的一种连接查询算法。

##### **11.2.2** **使用索引加快连接速度**





### **12** **第****12****章 谁最便宜就选谁****-MySQL****基于成本的优化**

在 MySQL 中一条查询语句的执行成本是由

下边这两个方面组成的：

* I/O 成本
* 我们的表经常使用的 MyISAM 、 InnoDB 存储引擎都是将数据和索引都存储到磁盘上的，当我们想查询表中的记录时，需要先把数据或者索引加载到内存中然后再操作。这个从磁盘到内存这个加载的过程损耗的时间称之为 I/O 成本。
* CPU 成本
* 读取以及检测记录是否满足对应的搜索条件、对结果集进行排序等这些操作损耗的时间称之为 CPU 成本。

对于 InnoDB 存储引擎来说，页是磁盘和内存之间交互的基本单位，设计 MySQL 的大叔规定读取一个页面花费的成本默认是 1.0 ，读取以及检测一条记录是否符合搜索条件的成本默认是 0.2 。 1.0 、 0.2 这些数字称之为 成本常数 ，

#### **12.2** **单表查询的成本**

##### **12.2.1** **准备工作**

```sql
CREATE TABLE single_table (

 id INT NOT NULL AUTO_INCREMENT,

 key1 VARCHAR(100),

 key2 INT,

 key3 VARCHAR(100),

 key_part1 VARCHAR(100),

 key_part2 VARCHAR(100),

 key_part3 VARCHAR(100),

 common_field VARCHAR(100),

 PRIMARY KEY (id),

 KEY idx_key1 (key1),

 UNIQUE KEY idx_key2 (key2),

 KEY idx_key3 (key3),

 KEY idx_key_part(key_part1, key_part2, key_part3)

) Engine=InnoDB CHARSET=utf8;
```

在一条单表查询语句真正执行之前， MySQL 的查询优化器会找出执行该语句所有可能使用的方案，对比之后找出

成本最低的方案，这个成本最低的方案就是所谓的 执行计划 ，之后才会调用存储引擎提供的接口真正的执行查

询，这个过程总结一下就是这样：

* 1. 根据搜索条件，找出所有可能使用的索引
  1. 计算全表扫描的代价
  1. 计算使用不同索引执行查询的代价
  1. 对比各种执行方案的代价，找出成本最低的那一个

###### **12.2.2.2 2.** **计算全表扫描的代价**

查询成本= I/O 成本+ CPU 成本，所以计算全表扫描的代价需要两个信息：

* 聚簇索引占用的页面数

* 该表中的记录数

TABLE STATUS 语句来查看表的统计信息，如果要看指定的某个表的统计信息，在该语句后加对应的 LIKE 语句就好了，比方说我们要查看 single_table 这个表的统计信息可以这么写：

```sql
mysql> USE xiaohaizi;

Database changed

mysql> SHOW TABLE STATUS LIKE 'single_table'\G

*************************** 1. row ***************************

 Name: single_table

 Engine: InnoDB

 Version: 10

 Row_format: Dynamic

 Rows: 9693

Avg_row_length: 163

 Data_length: 1589248

Max_data_length: 0

 Index_length: 2752512

 Data_free: 4194304

Auto_increment: 10001

 Create_time: 2018-12-10 13:37:23

 Update_time: 2018-12-10 13:38:03

 Check_time: NULL

 Collation: utf8_general_ci

 Checksum: NULL

Create_options:

 Comment:

1 row in set (0.01 sec)
```

我们目前只关心两个：

* Rows

本选项表示表中的记录条数。对于使用 MyISAM 存储引擎的表来说，该值是准确的，对于使用 InnoDB 存储引的表来说，该值是一个估计值。从查询结果我们也可以看出来，由于我们的 single_table 表是使用InnoDB 存储引擎的，所以虽然实际上表中有10000条记录，但是 SHOW TABLE STATUS 显示的 Rows 值只有9693条记录。

* Data_length

本选项表示表占用的存储空间字节数。使用 MyISAM 存储引擎的表来说，该值就是数据文件的大小，对于使用 InnoDB 存储引擎的表来说，该值就相当于聚簇索引占用的存储空间大小，也就是说可以这样计算该值的大小：

 Data_length = 聚簇索引的页面数量 x 每个页面的大小

我们的 single_table 使用默认 16KB 的页面大小，而上边查询结果显示 Data_length 的值是 1589248 ，所以我们可以反向来推导出 聚簇索引的页面数量 ：

 聚簇索引的页面数量 = 1589248 ÷ 16 ÷ 1024 = 97

* I/O 成本

 97 x 1.0 + 1.1 = 98.1

* CPU 成本：

 9693 x 0.2 + 1.0 = 1939.6

总成本：

 98.1 + 1939.6 = 2037.7



##### **13.2.2 innodb_index_stats**

![image-20240730102141366](D:\desktop\笔记\MySQL数据库\img\sql33.png)

注意这个表的主键是 (database_name,table_name,index_name,stat_name) ，其中的 stat_name 是指统计项的名

称，也就是说innodb_index_stats表的<font color='red'>每条记录代表着一个索引的一个统计项。</font>

先查看 index_name 列，这个列说明该记录是哪个索引的统计信息，从结果中我们可以看出来， PRIMARY 索引（也就是主键）占了3条记录， idx_key_part 索引占了6条记录。

针对 index_name 列相同的记录， stat_name 表示针对该索引的统计项名称， stat_value 展示的是该索引在该统计项上的值， stat_description 指的是来描述该统计项的含义的。我们来具体看一下一个索引都有哪些统计项：

* n_leaf_pages ：表示该索引的叶子节点占用多少页面。

* size ：表示该索引共占用多少页面。
* n_diff_pfxNN ：表示对应的索引列不重复的值有多少。其中的 NN 长得有点儿怪呀，啥意思呢？其实 NN 可以被替换为 01 、 02 、 03 ... 这样的数字。比如对于 idx_key_part 来说：
* n_diff_pfx01 表示的是统计 key_part1 这单单一个列不重复的值有多少。
* n_diff_pfx02 表示的是统计 key_part1、key_part2 这两个列组合起来不重复的值有多少。
* n_diff_pfx03 表示的是统计 key_part1、key_part2、key_part3 这三个列组合起来不重复的值有多少。
* n_diff_pfx04 表示的是统计 key_part1、key_part2、key_part3、id 这四个列组合起来不重复的值有多少

##### **13.2.3** **定期更新统计数据**

设计 MySQL 的大叔提供了如下两种更新统计数据的方式：

* 开启 innodb_stats_auto_recalc 。
* 系统变量 innodb_stats_auto_recalc 决定着服务器是否自动重新计算统计数据，它的默认值是 ON ，也就是该功能默认是开启的。每个表都维护了一个变量，该变量记录着对该表进行增删改的记录条数，如果发生变动的记录数量超过了表大小的 10% ，并且自动重新计算统计数据的功能是打开的，那么服务器会重新进行一次统计数据的计算，并且更新 innodb_table_stats 和 innodb_index_stats 表。不过自动重新计算统计数据的过程是异步发生的，也就是即使表中变动的记录数超过了 10% ，自动重新计算统计数据也不会立即发生，可能会延迟几秒才会进行计算。

再一次强调， InnoDB 默认是以表为单位来收集和存储统计数据的，我们也可以单独为某个表设置是否自动

重新计算统计数的属性，设置方式就是在创建或修改表的时候通过指定 STATS_AUTO_RECALC 属性来指明该表

的统计数据存储方式

* 手动调用 ANALYZE TABLE 语句来更新统计信息
* 如果 innodb_stats_auto_recalc 系统变量的值为 OFF 的话，我们也可以手动调用 ANALYZE TABLE 语句来重新计算统计数据，比如我们可以这样更新关于 single_table 表的统计数据：

```sql
 mysql> ANALYZE TABLE single_table;

s +------------------------+---------+----------+----------+

 | Table | Op | Msg_type | Msg_text |

 +------------------------+---------+----------+----------+

 | xiaohaizi.single_table | analyze | status | OK |

 +------------------------+---------+----------+----------+

 1 row in set (0.08 sec)
```

需要注意的是，ANALYZE TABLE语句会立即重新计算统计数据，也就是这个过程是同步的，在表中索引多

或者采样页面特别多时这个过程可能会特别慢，请不要没事儿就运行一下 ANALYZE TABLE 语句，最好在业务

不是很繁忙的时候再运行。

##### **13.2.1 innodb_table_stats**

直接看一下这个 innodb_table_stats 表中的各个列都是干嘛的：

![image-20240730111349243](.\img\sql34.png)

### **14** **第****14****章 不好看就要多整容****-MySQL****基于规则的优化（内**

**含关于子查询优化二三事儿）**

#### **14.1** **条件化简**

##### **14.1.1** **移除不必要的括号**

有时候表达式里有许多无用的括号

##### **14.1.2** **常量传递（****constant_propagation****）**

当这个表达式和其他涉及列 a 的表达式使用 AND 连接起来时，可以将其他表达式中的 a 的值替换为 5

##### **14.1.3** **等值传递（****equality_propagation****）**

有时候多个列之间存在等值匹配的关系，比如这样：

a = b and b = c and c = 5

这个表达式可以被简化为：

a = 5 and b = 5 and c = 5

##### **14.1.5** **表达式计算**

在查询开始执行之前，如果表达式中只包含常量的话，它的值会被先计算出来，比如这个：

a = 5 + 1

因为 5 + 1 这个表达式只包含常量，所以就会被化简成：

a = 6

但是这里需要注意的是，如果某个列并不是以单独的形式作为表达式的操作数时，比如出现在函数中，出现在某个更复杂表达式中，就像这样：

ABS(a) > 5

或者：-a < -8优化器是不会尝试对这些表达式进行化简的。我们前边说过只有搜索条件中索引列和常数使用某些运算符连接起来才可能使用到索引，所以如果可以的话，最好让索引列以单独的形式出现在表达式中。





#### **14.2** **外连接消除**

<font color ='red'>外连接和内连接的本质区别就是：对于外连接的驱动表的记录来说，如果无法在被驱动表中找到匹配ON子句中的过滤条件的记录，那么该记录仍然会被加入到结果集中，对应的被驱动表记录的各个字段使用NULL值填充；而内连接的驱动表的记录如果无法在被驱动表中找到匹配ON子句中的过滤条件的记录，那么该记录会被舍弃。</font>查询效果就是这样：

#### **14.3** **子查询优化**

子查询可以在一个外层查询的各种位置出现，比如：

* SELECT 子句中，也就是我们平时说的查询列表中，比如这样：

```sql
 mysql> SELECT (SELECT m1 FROM t1 LIMIT 1);

 +-----------------------------+

 | (SELECT m1 FROM t1 LIMIT 1) |

 +-----------------------------+

 | 1 |

 +-----------------------------+

 1 row in set (0.00 sec)
```

其中的 (SELECT m1 FROM t1 LIMIT 1) 就是我们唠叨的所谓的 子查询 。

* FROM 子句中，比如： 

```sql
SELECT m, n FROM (SELECT m2 + 1 AS m, n2 AS n FROM t2 WHERE m2 > 2) AS t;

 +------+------+

 | m | n |

 +------+------+

 | 4 | c |

 | 5 | d |

 +------+------+

 2 rows in set (0.00 sec)
```

这个例子中的子查询是： (SELECT m2 + 1 AS m, n2 AS n FROM t2 WHERE m2 > 2) ，很特别的地方是它出现在了 FROM 子句中。 FROM 子句里边儿不是存放我们要查询的表的名称么，这里放进来一个子查询是个派生表 

* WHERE 或 ON 子句中

```sql
mysql> SELECT * FROM t1 WHERE m1 IN (SELECT m2 FROM t2);

 +------+------+

 | m1 | n1 |

 +------+------+

 | 2 | b |

 | 3 | c |

 +------+------+

 2 rows in set (0.00 sec)
```



###### **14.3.1.1** **按返回的结果集区分子查询**

* 标量子查询

那些只返回一个单一值的子查询称之为 标量子查询 ，比如这样：

 SELECT (SELECT m1 FROM t1 LIMIT 1);

或者这样：

 SELECT * FROM t1 WHERE m1 = (SELECT MIN(m2) FROM t2);

这两个查询语句中的子查询都返回一个单一的值，也就是一个 标量 。这些标量子查询可以作为一个单一值或者表达式的一部分出现在查询语句的各个地方。

* 行子查询

顾名思义，就是返回一条记录的子查询，不过这条记录需要包含多个列（只包含一个列就成了标量子查询了）。比如这样：

 SELECT * FROM t1 WHERE (m1, n1) = (SELECT m2, n2 FROM t2 LIMIT 1);

其中的 (SELECT m2, n2 FROM t2 LIMIT 1) 就是一个行子查询，整条语句的含义就是要从 t1 表中找一些记

录，这些记录的 m1 和 n2 列分别等于子查询结果中的 m2 和 n2 列。

* 列子查询

列子查询自然就是查询出一个列的数据喽，不过这个列的数据需要包含多条记录（只包含一条记录就成了标量子查询了）。比如这样：

 SELECT * FROM t1 WHERE m1 IN (SELECT m2 FROM t2);

其中的 (SELECT m2 FROM t2) 就是一个列子查询，表明查询出 t2 表的 m2 列的值作为外层查询 IN 语句的参数。

* 表子查询

顾名思义，就是子查询的结果既包含很多条记录，又包含很多个列，比如这样：

 SELECT * FROM t1 WHERE (m1, n1) IN (SELECT m2, n2 FROM t2);

其中的 (SELECT m2, n2 FROM t2) 就是一个表子查询，这里需要和行子查询对比一下，行子查询中我们用了 LIMIT 1 来保证子查询的结果只有一条记录，表子查询中不需要这个限制

###### **14.3.1.2** **按与外层查询关系来区分子查询**

* 不相关子查询

如果子查询可以单独运行出结果，而不依赖于外层查询的值，我们就可以把这个子查询称之为 不相关子查询 。我们前边介绍的那些子查询全部都可以看作不相关子查询，所以也就不举例子了哈。

* 相关子查询

如果子查询的执行需要依赖于外层查询的值，我们就可以把这个子查询称之为 相关子查询 。比如：

 SELECT * FROM t1 WHERE m1 IN (SELECT m2 FROM t2 WHERE n1 = n2);

###### **14.3.1.3** **子查询在布尔表达式中的使用**

* 使用 = 、 > 、 < 、 >= 、 <= 、 <> 、 != 、 <=> 作为布尔表达式的操作符

* 这里的子查询只能是标量子查询或者行子查询，也就是子查询的结果只能<font color='red'>返回一个单一的值或者只能是一条记录。比如这样（标量子查询）：</font>

  ```
   SELECT * FROM t1 WHERE m1 < (SELECT MIN(m2) FROM t2);
  ```

* [NOT] IN/ANY/SOME/ALL子查询

  对于列子查询和表子查询来说，它们的结果集中包含很多条记录，这些记录相当于是一个集合，所以就不能单纯的和另外一个操作数使用 comparison_operator 来组成布尔表达式了， MySQL 通过下面的语法来支持某个操作数和一个集合组成一个布尔表达式：

  * IN 或者 NOT IN

  具体的语法形式如下：

   操作数 [NOT] IN (子查询)

  这个布尔表达式的意思是用来判断某个操作数在不在由子查询结果集组成的集合中，比如下边的查询的意思是找出 t1 表中的某些记录，这些记录存在于子查询的结果集中：

  ```
   SELECT * FROM t1 WHERE (m1, n2) IN (SELECT m2, n2 FROM t2);
  ```

  * ANY/SOME （ ANY 和 SOME 是同义词）

  具体的语法形式如下：

   操作数 comparison_operator ANY/SOME(子查询)

  这个布尔表达式的意思是只要子查询结果集中存在某个值和给定的操作数做 comparison_operator 比较结果为 TRUE ，那么整个表达式的结果就为 TRUE ，否则整个表达式的结果就为 FALSE 。比方说下边这个查询：

  ```
   SELECT * FROM t1 WHERE m1 > ANY(SELECT m2 FROM t2);
  ```

  这个查询的意思就是对于 t1 表的某条记录的 m1 列的值来说，如果子查询 (SELECT m2 FROM t2) 的结果集中存在一个小于 m1 列的值，那么整个布尔表达式的值就是 TRUE ，否则为 FALSE ，也就是说只要m1 列的值大于子查询结果集中最小的值，整个表达式的结果就是 TRUE ，所以上边的查询本质上等价于这个查询：

  ```
   SELECT * FROM t1 WHERE m1 > (SELECT MIN(m2) FROM t2);
  ```

  另外，=ANY相当于判断子查询结果集中是否存在某个值和给定的操作数相等，它的含义和IN是相同

  的。

  * ALL

  具体的语法形式如下： 操作数 comparison_operator ALL(子查询)

  * EXISTS子查询

  * 有的时候我们仅仅需要判断子查询的结果集中是否有记录，而不在乎它的记录具体是个啥，可以使用把EXISTS 或者 NOT EXISTS 放在子查询语句前边，就像这样：

     [NOT] EXISTS (子查询)

    我们举一个例子啊：

     SELECT * FROM t1 WHERE EXISTS (SELECT 1 FROM t2);

###### **14.3.1.4** **子查询语法注意事项**

<font color='red'>子查询必须用小括号扩起来。不扩起来的子查询是非法的。</font>

### **18** **第****18****章 调节磁盘和****CPU****的矛盾****-InnoDB****的****Buffer**